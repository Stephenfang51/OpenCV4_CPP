<h1 align="center">OpenCV C++</h1>

ä¸ºä½•ç¼–å†™è¯¥ç¬”è®°ï¼Œ å› ä¸ºç½‘ä¸Šå„ç§åšæ–‡å†™çš„å¤ªåƒåœ¾ï¼Œ äºæ˜¯è‡ªå·±å†™ä¸€ä»½äººäººéƒ½èƒ½è¿…é€Ÿç†è§£çš„ç¬”è®°ï¼Œ å…è´¹ä¾›å¤§å®¶æŸ¥é˜…ï¼Œ ä»¥ä¸‹å†…å®¹ä»¥Opencv 3.4.8 C++ APIæ¥å£ ä¸ºåŸºç¡€ï¼Œ åŒæ—¶ä¹Ÿä¼šæœ‰Cæ¥å£ (OpenCV 2.4.8)è¡¥å……è¯´æ˜

<h5 align='right' > update 2020.9.14</h5>

### ç›®å½•

> å®‰è£…
>
> 1. åŸºæœ¬
> 2. å›¾åƒå¤„ç†
> 3. æ¨¡æ¿åŒ¹é…
> 4. å¯¹è§†é¢‘oræ‘„åƒå¤´è¯»å–
> 5. å„ç±»å‹(Vec, Scalar, Point, Size, Rect)
> 6. API
>
> - ç›®å½•å¾…ç¼–è¾‘***
>
> 6. CMakeLists.txt ç¼–å†™
> 7. Gstream
> 8. å…¶ä»–
>    - ç›®å½•å¾…ç¼–è¾‘***
> 9. å‚è€ƒèµ„æ–™
>
> 

### å®‰è£…

MacOS åŸºäºHomebrewå®‰è£…

```shell
brew install opencv
```

ä¼šè€—æ—¶çº¦3ä¸ªå°æ—¶å·¦å³æ‰å®‰è£…å®Œæ¯•ï¼Œ ç»“æŸä¹‹åç›´æ¥å®‰è£…å¥½æœ€æ–°ç‰ˆæœ¬openCV



CMakelistä¸­é…ç½®

```cmake
#opencv
find_package(OpenCV REQUIRED)
message("OpenCV version: " ${OpenCV_VERSION})
include_directories(${OpenCV_INCLUDE_DIRS} )
link_directories(${OpenCV_LIB_DIR})



target_link_libraries(xxxx ${OpenCV_LIBS}) //xxxxè¡¨ç¤ºè‡ªå·±çš„æ‰§è¡Œæ–‡ä»¶åç§°
```

### 1. åŸºæœ¬

#### Mat

ä¸»è¦ç”¨æ¥å­˜å‚¨å›¾åƒ

Ref http://zhaoxuhui.top/blog/2019/08/24/OpenCV-Mat-Note.html

åœ¨æ—©æœŸOpenCVä¸­(OpenCV 1.x)å¤§é‡ä½¿ç”¨`IplImage`ã€`CvMat`å®ç°æ•°æ®å¤„ç†ï¼Œå…¶éœ€è¦æ‰‹åŠ¨è¿›è¡Œå†…å­˜ç®¡ç†ï¼Œä½¿ç”¨ä¸æ˜¯å¾ˆæ–¹ä¾¿ã€‚åˆ°OpenCV 2.xç‰ˆæœ¬åå¼•å…¥C++é¢å‘å¯¹è±¡æ€æƒ³ï¼Œé‡æ„äº†ä»£ç ï¼Œå¼•å…¥`Mat`ã€‚ä½œä¸ºå‡çº§ï¼Œ`Mat`å­˜å‚¨çš„æ•°æ®ç»“æ„ä¸`CvMat`ã€`IplImage`ç­‰å®Œå…¨å…¼å®¹ï¼Œä¹Ÿå’Œ`Numpy(ndarray)`å…¼å®¹

åˆ›å»º`Mat`æœ‰å¤šç§æ–¹æ³•ï¼Œå¸¸è§çš„æœ‰ä»¥ä¸‹å‡ ç§, å¯ä»¥ä¸€ä¸€å¯¹ç…§

```c++
#include <iostream>
#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

int main() {
    Mat m1(4, 3, CV_8UC1);
    cout << m1 << endl << endl;

    Mat m2(3, 5, CV_8UC1, 200);
    cout << m2 << endl << endl;

    Mat m3(2, 4, CV_8UC1, -10);
    cout << m3 << endl << endl;

    Mat m4;
    m4.create(2, 3, CV_8UC1);
    cout << m4 << endl;
    cout << "CV_8UC1" << endl;
    cout << "channels:" << m4.channels() << endl;
    cout << "row & col:" << m4.rows << " & " << m4.cols << endl;
    cout << "size:" << m4.size << endl;
    cout << "dims:" << m4.dims << endl << endl;

    Mat m5(3, 2, CV_8UC3, Scalar(20, 10, 30));
    cout << m5 << endl;
    cout << "CV_8UC3" << endl;
    cout << "channels:" << m5.channels() << endl;
    cout << "row & col:" << m5.rows << " & " << m5.cols << endl;
    cout << "size:" << m5.size << endl;
    cout << "dims:" << m5.dims << endl << endl;

    Mat m6(3, 2, CV_8UC(5));
    cout << m6 << endl;
    cout << "CV_8UC5" << endl;
    cout << "channels:" << m6.channels() << endl;
    cout << "row & col:" << m6.rows << " & " << m6.cols << endl;
    cout << "size:" << m6.size << endl;
    cout << "dims:" << m6.dims << endl << endl;

    int sz[] = {3, 4, 2};
    Mat m7(3, sz, CV_8U, Scalar::all(0));
    cout << "CV_8U" << endl;
    cout << "m7 can't print out,because m7.dims = 3 and it requires m.dims <= 2" << endl;
    cout << "channels:" << m7.channels() << endl;
    cout << "row & col:" << m7.rows << " & " << m7.cols << endl;
    cout << "size:" << m7.size << endl;
    cout << "dims:" << m7.dims << endl << endl;
    return 0;
}


>>> output
[  0,   0,   0;
   0,   0,   0;
   0,   0,   0;
   0,   0,   0]

[200, 200, 200, 200, 200;
 200, 200, 200, 200, 200;
 200, 200, 200, 200, 200]

[  0,   0,   0,   0;
   0,   0,   0,   0]

[  0,   0,   0;
   0,   0,   0]
CV_8UC1
channels:1
row & col:2 & 3
size:2 x 3
dims:2

[ 20,  10,  30,  20,  10,  30;
  20,  10,  30,  20,  10,  30;
  20,  10,  30,  20,  10,  30]
CV_8UC3
channels:3
row & col:3 & 2
size:3 x 2
dims:2

[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0;
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]
CV_8UC5
channels:5
row & col:3 & 2
size:3 x 2
dims:2

CV_8U
m7 can't print out,because m7.dims = 3 and it requires m.dims <= 2
channels:1
row & col:-1 & -1
size:3 x 4 x 2
dims:3
```





åˆ©ç”¨clone æˆ–è€…èµ‹å€¼å‡½æ•°, ä»¥åŠatæ”¹å˜å…ƒç´ å€¼

```cpp
#include <iostream>
#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

int main() {
    Mat m1(Size(3, 2), CV_16S, Scalar(-3));
    Mat m2(m1);

    Mat m3 = m1;
    Mat m4 = imread("img.jpg");
    Mat m5 = m1.clone();

    m3.at<short>(1, 1) = 2;
    m5.at<short>(0, 1) = 9;
    cout << "m1:" << endl << m1 << endl << endl;
    cout << "m2:" << endl << m2 << endl << endl;
    cout << "m3:" << endl << m3 << endl << endl;
    cout << "m5:" << endl << m5 << endl;
    return 0;
}


>>> output
m1:
[-3, -3, -3;
 -3, 2, -3]

m2:
[-3, -3, -3;
 -3, 2, -3]

m3:
[-3, -3, -3;
 -3, 2, -3]

m5:
[-3, 9, -3;
 -3, -3, -3]
```



#### IplImage 

OpenCV æ—©æœŸç‰ˆæœ¬å›¾åƒå­˜å‚¨çš„ç»“æ„ä½“



åˆ›å»ºå›¾åƒ

```c++
IplImage * src_img = cvCreateImage(cvSize, depth, channel)
```





#### å¸¸ç”¨å¤´æ–‡ä»¶

```c++
#include "opencv2/core.hpp" //ä¸»è¦åŒ…å«äº†opencvåŸºæœ¬æ•°æ®ç»“æ„ï¼ŒåŠ¨æ€æ•°æ®ç»“æ„ï¼Œç»˜å›¾å‡½æ•°ï¼Œæ•°ç»„æ“ä½œç›¸å…³å‡½æ•°ï¼Œè¾…åŠ©åŠŸèƒ½ä¸ç³»ç»Ÿå‡½æ•°å’Œå®
#include "opencv2/imgproc.hpp" //å›¾åƒå¤„ç†æ¨¡å—
#include "opencv2/video.hpp" //è§†é¢‘æ¨¡å—
#include "opencv2/objdetect.hpp" //
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp" //é«˜å±‚IOï¼Œ ä¸€äº›å¯è§†åŒ–æ¨¡å—ä¾‹å¦‚imshowï¼Œ imreadï¼Œ imwrite..etc
#include "opencv2/ml.hpp" //æœºå™¨å­¦ä¹ æ¨¡å—
#include "vector" //å®¹å™¨ï¼Œ å¯ç”¨æ¥å­˜å‚¨å„ç§æ•°æ®

æˆ–è€…å¯ä»¥ç®€å•çš„ç›´æ¥
#include<opencv2/opencv.hpp> //opencv.hppçš„å¤´æ–‡ä»¶åŒ…å«äº†opencvåº“é‡Œçš„æ‰€æœ‰å¤´æ–‡ä»¶
```





### 2. å›¾åƒå¤„ç†

#### åŠ è½½å›¾åƒ

```c++
Mat color = imread("test.jpg"); //è¯»å–ä¸ºå½©è‰²å›¾åƒ

Mat gray = imread("test.jpg", CV_LOAD_IMAGE_GRAYSCALE); //æŒ‡å®šè¯»å–ä¸ºç°åº¦å›¾
```



#### è®¿é—®å›¾åƒçš„è¡Œæˆ–è€…åˆ—

```c++
int MyRaw = color.cols-1;
int MyCol = color.rows-1;
```



#### è®¿é—®å›¾åƒä¸­çš„æŸä¸ªåƒç´ 

```c++
//cv::Mat::at<typename>(row, col)
Vec3b pixel = color.at<Vec3b>(myRow, myCol);
cout << "Pixel value (B, G, R): (" << (int)pixel[0] << ", " << (int)pixel[1] << ", " << (int)pixel[2]<<")" << endl;
```

8ä½å½©è‰²å›¾åƒçš„ç±»å‹æ˜¯Vec3b ï¼ˆVec = å‘é‡ï¼Œ 3 = ç»„ä»¶æ•°ï¼Œ b = ä¸€ä¸ªå­—èŠ‚ï¼‰



#### å±•ç¤ºå›¾åƒ

```C++
imshow("Test_bgr", color);
imshow("Test_gray", gray);
waitkey(0); 
```

waitkeyè¡¨ç¤ºç­‰å¾…ç”¨æˆ·æŒ‰ä¸‹æŸä¸ªé”®å°±å…³é—­çª—å£ï¼Œ 0è¡¨ç¤ºä»»ä½•é”®



#### resizeå›¾åƒ

å°†å›¾åƒå¤§å°ç¼©æ”¾

```c++
void cv::resize	(	InputArray 	src,
OutputArray 	dst,
Size 	dsize,
double 	fx = 0,
double 	fy = 0,
int interpolation = INTER_LINEAR 
)
```

Ex.

```c++
cv::resize(src, dst, Size(xxx, xxx), 0, 0, INTER_LINEAR)
```





#### åˆ›é€ ä¸€ä¸ªåƒç´ ç‚¹å…¨ä¸º0çš„å›¾åƒ

```
cv::Mat::zeros()
```



#### å›¾åƒROIåŒºåŸŸé€‰å®š

C++

ex. åœ¨åŸå›¾ä¸Š åˆ©ç”¨`cv::Rect`é€‰å®šå‡ºroiåŒºåŸŸï¼Œ å¯ä»¥åœ¨æ­¤roiä¸Šåšå˜åŒ–ï¼Œ æ¯”å¦‚æ”¹å˜é¢œè‰²ä¹‹ç±»çš„

```c++
Mat orange = imread("./images/orange.png");

Mat roi = orange(Rect(0, 0, apple.cols, apple.rows));
```



C 

Cçš„æ–¹æ³•ä¸»è¦æ˜¯å°†åŸå›¾å˜ä¸ºroi

```c
void cvSetImageROI(IplImage* image, CvRect rect)
```

ç”¨æ³•

```
//æ¯”å¦‚è¦å–
cvSetImageROI(src_img, cvRect(150, 150, 100, 100)); //è¿™æ—¶å€™åŸå›¾å·²ç»å˜æˆroiçš„åŒºåŸŸäº†


cvShowImage("test", src_img); //è¿™æ—¶å€™ä¼šå‘ç°æ˜¾ç¤ºçš„å·²ç»æ˜¯roiåŒºåŸŸï¼Œ è€Œä¸æ˜¯åŸå›¾å¤§å°

//å¯å–å¾—roiçš„å®½é«˜ä¿¡æ¯
src_img->roi->width;
src_img->roi->height;


//é‡Šæ”¾roiï¼Œ å˜å›åŸæ¥çš„å›¾åƒ
cvResetImageROI(src_img);
```





#### å›¾åƒå¤åˆ¶çš„æ–¹æ³•

**CopyTo**çš„æ–¹æ³•æœ‰ä¸¤ç§

ç¬¬ä¸€ä¸ªåŠŸèƒ½å…¶å®å°±æ˜¯æŠŠè¾“å…¥å›¾åƒå®Œå®Œå…¨å…¨æ‹·è´åˆ°è¾“å‡ºå›¾åƒä¸Šï¼Œå¹¶ä¸”å°†è¾“å‡ºå›¾åƒçš„å¤§å°è°ƒæ•´æˆè¾“å…¥å›¾åƒçš„å¤§å°

```
void copyTo( OutputArray m ) const;
```





```
void copyTo(OutputArray m, InputArray mask) const;
```

ä¹Ÿå°±æ˜¯å‚æ•°å¯ä»¥æ˜¯ä¸€å¼ è¾“å‡ºå›¾åƒï¼Œæˆ–è€…ä¸€å¼ è¾“å‡ºå›¾åƒå’Œä¸€ä¸ªæ©ç å›¾

//TODO maskå‚æ•°çš„ç”¨æ³•å¾…äº†è§£



**clone()**





åŒºåˆ«ï¼š å½“ç›®æ ‡çŸ©é˜µä¸æºçŸ©é˜µå…·æœ‰ç›¸åŒçš„typeå’Œsizeæ—¶ï¼ŒcopyToä¸ä¼šä¸ºç›®æ ‡çŸ©é˜µé‡æ–°åˆ†é…å†…å­˜

è€Œcloneæ€»æ˜¯ä¼šä¸ºç›®æ ‡çŸ©é˜µé‡æ–°åˆ†é…å†…å­˜

```c++
#copyTo
Mat mat1 = Mat::ones(1, 5, CV_32F);   // [1,1,1,1,1]
Mat mat2 = mat1;   // mat2ä¸mat1æŒ‡å‘åŒä¸€å†…å­˜åœ°å€
Mat mat3 = Mat::zeros(1, 5, CV_32F);  // [0,0,0,0,0]
mat3.copyTo(mat1); // mat1æœªè¢«é‡æ–°åˆ†é…å†…å­˜ï¼Œé€šè¿‡mat1å¯ä»¥æ”¹å˜mat2çš„å†…å®¹
cout << mat1 << endl;   // [0,0,0,0,0] 
cout << mat2 << endl;   // [0,0,0,0,0]

#clone()
Mat mat1 = Mat::ones(1, 5, CV_32F);   // [1,1,1,1,1]
Mat mat2 = mat1;   // mat2ä¸mat1æŒ‡å‘åŒä¸€å†…å­˜åœ°å€
Mat mat3 = Mat::zeros(1, 5, CV_32F);   // [0,0,0,0,0]
mat1 = mat3.clone();   // mat1è¢«é‡æ–°åˆ†é…å†…å­˜ï¼Œé€šè¿‡mat1ä¸èƒ½æ”¹å˜mat2çš„å†…å®¹
cout << mat1 << endl;   // [0,0,0,0,0]
cout << mat2 << endl;   // [1,1,1,1,1]

```





#### å›¾åƒè¿ç®—ç¬¦æ“ä½œ

æ¯”å¦‚ä¸¤å¹…å›¾åƒå¯ä»¥ç›¸åŠ ã€ç›¸å‡ã€ç›¸ä¹˜ã€ç›¸é™¤ã€ä½è¿ç®—ã€å¹³æ–¹æ ¹ã€å¯¹æ•°ã€ç»å¯¹å€¼ç­‰ï¼›å›¾åƒä¹Ÿå¯ä»¥æ”¾å¤§ã€ç¼©å°ã€æ—‹è½¬ï¼Œè¿˜å¯ä»¥æˆªå–å…¶ä¸­çš„ä¸€éƒ¨åˆ†ä½œä¸ºROIï¼ˆæ„Ÿå…´è¶£åŒºåŸŸï¼‰è¿›è¡Œæ“ä½œï¼Œå„ä¸ªé¢œè‰²é€šé“è¿˜å¯ä»¥åˆ†åˆ«æå–åŠå¯¹å„ä¸ªé¢œè‰²é€šé“è¿›è¡Œå„ç§è¿ç®—æ“ä½œã€‚æ€»ä¹‹ï¼Œå¯¹äºå›¾åƒå¯ä»¥è¿›è¡Œçš„åŸºæœ¬è¿ç®—éå¸¸çš„å¤šï¼Œåªæ˜¯æŒ‘äº†äº›å¸¸ç”¨çš„æ“ä½œè¯¦è§£

```c++
void add(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray(), int dtype=-1);//dst = src1 + src2
void subtract(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray(), int dtype=-1);//dst = src1 - src2
void multiply(InputArray src1, InputArray src2,OutputArray dst, double scale=1, int dtype=-1);//dst = scale*src1*src2
void divide(InputArray src1, InputArray src2, OutputArray dst,double scale=1, int dtype=-1);//dst = scale*src1/src2
void divide(double scale, InputArray src2,OutputArray dst, int dtype=-1);//dst = scale/src2
void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);//dst = alpha*src1 + src2
void addWeighted(InputArray src1, double alpha, InputArray src2,double beta, double gamma, OutputArray dst, int dtype=-1);//dst = alpha*src1 + beta*src2 + gamma
void sqrt(InputArray src, OutputArray dst);//è®¡ç®—æ¯ä¸ªçŸ©é˜µå…ƒç´ çš„å¹³æ–¹æ ¹
void pow(InputArray src, double power, OutputArray dst);//srcçš„poweræ¬¡å¹‚
void exp(InputArray src, OutputArray dst);//dst = e**srcï¼ˆ**è¡¨ç¤ºæŒ‡æ•°çš„æ„æ€ï¼‰
void log(InputArray src, OutputArray dst);//dst = log(abs(src))
```



```c++
void bitwise_and(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 & src2
void bitwise_or(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 | src2
void bitwise_xor(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 ^ src2
void bitwise_not(InputArray src, OutputArray dst,InputArray mask=noArray());//dst = ~src

```

bitwise_andæ˜¯å¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡Œâ€œä¸â€æ“ä½œï¼Œå³å¯¹å›¾åƒï¼ˆç°åº¦å›¾åƒæˆ–å½©è‰²å›¾åƒå‡å¯ï¼‰æ¯ä¸ªåƒç´ å€¼è¿›è¡ŒäºŒè¿›åˆ¶â€œä¸â€æ“ä½œï¼Œ1&1=1ï¼Œ1&0=0ï¼Œ0&1=0ï¼Œ0&0=0
bitwise_oræ˜¯å¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡Œâ€œæˆ–â€æ“ä½œï¼Œå³å¯¹å›¾åƒï¼ˆç°åº¦å›¾åƒæˆ–å½©è‰²å›¾åƒå‡å¯ï¼‰æ¯ä¸ªåƒç´ å€¼è¿›è¡ŒäºŒè¿›åˆ¶â€œæˆ–â€æ“ä½œï¼Œ1|1=1ï¼Œ1|0=0ï¼Œ0|1=0ï¼Œ0|0=0
bitwise_xoræ˜¯å¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡Œâ€œå¼‚æˆ–â€æ“ä½œï¼Œå³å¯¹å›¾åƒï¼ˆç°åº¦å›¾åƒæˆ–å½©è‰²å›¾åƒå‡å¯ï¼‰æ¯ä¸ªåƒç´ å€¼è¿›è¡ŒäºŒè¿›åˆ¶â€œå¼‚æˆ–â€æ“ä½œï¼Œ1^1=0,1^0=1,0^1=1,0^0=0
bitwise_notæ˜¯å¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡Œâ€œéâ€æ“ä½œï¼Œå³å¯¹å›¾åƒï¼ˆç°åº¦å›¾åƒæˆ–å½©è‰²å›¾åƒå‡å¯ï¼‰æ¯ä¸ªåƒç´ å€¼è¿›è¡ŒäºŒè¿›åˆ¶â€œéâ€æ“ä½œï¼Œ~1=0ï¼Œ~0=1



#### å°†å›¾åƒé€šé“åˆ†ç±»åŠåˆå¹¶ cv::split / cv::merge

https://blog.csdn.net/guduruyu/article/details/70837779

å¤„ç†å¤šé€šé“å›¾åƒæ—¶ï¼Œæœ‰æ—¶éœ€è¦å¯¹å„ä¸ªé€šé“è¿›è¡Œåˆ†ç¦»ï¼Œåˆ†åˆ«å¤„ç†ï¼›æœ‰æ—¶è¿˜éœ€è¦å¯¹åˆ†ç¦»å¤„ç†åçš„å„ä¸ªé€šé“è¿›è¡Œåˆå¹¶ï¼Œé‡æ–°åˆå¹¶æˆä¸€ä¸ªå¤šé€šé“çš„å›¾åƒ

```C++
int main()
{
	cv::Mat src = imread("lenna.jpg", cv::IMREAD_COLOR);
	cv::imshow("src", src);
 
	// Split the image into different channels
	std::vector<cv::Mat> rgbChannels(3);
	split(src, rgbChannels);
 
	// Show individual channels
	cv::Mat blank_ch, fin_img;
	blank_ch = cv::Mat::zeros(cv::Size(src.cols, src.rows), CV_8UC1);
 
	// Showing Red Channel
	// G and B channels are kept as zero matrix for visual perception
	std::vector<cv::Mat> channels_r;
	channels_r.push_back(blank_ch);
	channels_r.push_back(blank_ch);
	channels_r.push_back(rgbChannels[2]);
 
	/// Merge the three channels
	cv::merge(channels_r, fin_img);
	cv::imshow("R", fin_img);
	
 
	// Showing Green Channel
	std::vector<cv::Mat> channels_g;
	channels_g.push_back(blank_ch);
	channels_g.push_back(rgbChannels[1]);
	channels_g.push_back(blank_ch);
	cv::merge(channels_g, fin_img);
	cv::imshow("G", fin_img);
	
 
	// Showing Blue Channel
	std::vector<cv::Mat> channels_b;
	channels_b.push_back(rgbChannels[0]);
	channels_b.push_back(blank_ch);
	channels_b.push_back(blank_ch);
	cv::merge(channels_b, fin_img);
	cv::imshow("B", fin_img);
	
	cv::waitKey(0);
	return 0;
}

```



#### æ”¹å˜å›¾åƒè‰²å½©ç©ºé—´

```C++
void cv::cvtColor	(	InputArray 	src, OutputArray 	dst, int 	code, int dstCn = 0 )	
```

- code ä¸»è¦åŒ…å«å„ç§è‰²å½©è½¬æ¢æ¥å£
  - https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga4e0972be5de079fed4e3a10e24ef5ef0
- dstCn : è¾“å‡ºçš„å›¾åƒçš„é€šé“æ•°ï¼Œ é»˜è®¤ä¸º0è¡¨ç¤ºè·ŸåŸå›¾åƒä¸€æ ·



#### å­˜å–å›¾åƒ

```c++
bool cv::imwrite	(	const String & 	filename, InputArray 	img, const std::vector< int > & 	params = std::vector< int >())
```

- filename : Name of the file.
- img : Image to be saved.
- params : Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see [cv::ImwriteFlags](https://docs.opencv.org/3.4/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac)

#### å›¾åƒå»å™ª - æ»¤æ³¢å™¨

**é«˜æ–¯æ»¤æ³¢**

å¯ä»¥æ¨¡ç³ŠåŒ–å›¾ç‰‡ï¼Œ ä¹Ÿæœ‰æŠ—å™ªå£°çš„æ•ˆæœ

```c++
void cv::GaussianBlur	(	InputArray 	src,
OutputArray 	dst,
Size 	ksize,
double 	sigmaX,
double 	sigmaY = 0,
int 	borderType = BORDER_DEFAULT 
)
```

| src        | input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. |
| ---------- | ------------------------------------------------------------ |
| dst        | output image of the same size and type as src.               |
| ksize      | Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. |
| sigmaX     | Gaussian kernel standard deviation in X direction.           |
| sigmaY     | Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see [getGaussianKernel](https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa) for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY. |
| borderType | pixel extrapolation method, see [BorderTypes](https://docs.opencv.org/3.4/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5). [BORDER_WRAP](https://docs.opencv.org/3.4/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a697c1b011884a7c2bdc0e5caf7955661) is not supported. |





#### é˜ˆå€¼å¤„ç† Threshold

å¯¹å›¾åƒçŸ©é˜µä¸Šæ¯ä¸€ä¸ªåƒç´ ç‚¹è¿›è¡Œå¤„ç†

C++ 

```c++
double cv::threshold	(	InputArray 	src, OutputArray 	dst, double 	thresh, double 	maxval,
int type )	
```

- Thresh : threshold value.
- maxval : maximum value to use with the [THRESH_BINARY](https://docs.opencv.org/4.2.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59) and [THRESH_BINARY_INV](https://docs.opencv.org/4.2.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754) thresholding types.
- threshold type :æŸ¥çœ‹https://docs.opencv.org/4.2.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576



C

```c
C: double cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type)
```

threshold å°±æ˜¯è‡ªå·±è®¾ç½®çš„é˜ˆå€¼

max_value å°±æ˜¯å½“åƒç´ å€¼å¤§äºé˜ˆå€¼çš„æ—¶å€™ï¼Œ ç»™ä¸çš„å€¼ä¸ºå¤šå°‘ï¼Ÿ





##### äºŒå€¼åŒ–

```c++

```







#### éœå¤«æ£€æµ‹ï¼ˆçº¿ï¼Œ åœ†ï¼‰

**éœå¤«ç›´çº¿**

ç†è®ºå‚è€ƒ https://blog.csdn.net/weixin_44638957/article/details/105881922

```c++
void cv::HoughLines( 
  cv::InputArray image, 
  cv::OutputArray lines, 
  double rho, double theta, 
  int threshold, 
  double srn = 0, 
  double stn = 0 );

// Input single channel image 
// N-by-1 two-channel array 
// rho resolution (pixels) 
// theta resolution (radians) 
// Unnormalized accumulator threshold 
// rho refinement (for MHT) 
// theta refinement (for MHT)
```

```c++
void cv::HoughLinesP	(	InputArray 	image,
OutputArray 	lines,
double 	rho,
double 	theta,
int 	threshold,
double 	minLineLength = 0,
double 	maxLineGap = 0 
)
```



- Image è¾“å…¥å›¾åƒ
- Lines è¾“å‡ºç›´çº¿
- Rho æåæ ‡rå¾—æ­¥é•¿
- Thetaè§’åº¦æ­¥é•¿
- Thresholdç´¯åŠ å™¨é˜ˆå€¼
- Srnã€stnå¤šå°ºåº¦éœå¤«å˜æ¢æ—¶å€™éœ€è¦å¾—å‚æ•°ï¼Œç»å…¸éœå¤«å˜æ¢ä¸éœ€è¦
- Min_theta :  é™å®šæœ€å°è§’åº¦
- Max_theta ï¼š é™å®šåœ¨min_theta åŠCV_PIä¹‹é—´
- double *minLineLength* = 0
- double *maxLineGap* = `0` 





```c++
void cv::HoughCircles	(	InputArray 	image,
OutputArray 	circles,
int 	method,
double 	dp,
double 	minDist,
double 	param1 = 100,
double 	param2 = 100,
int 	minRadius = 0,
int 	maxRadius = 0 
)	
```



**éœå¤«åœ†**

å‚è€ƒ https://blog.csdn.net/weixin_44638957/article/details/105883829



```cpp
void HoughCircles( InputArray image, 
                  OutputArray circles,
									int method, 
                  double dp, 
                  double minDist,
									double param1=100, 
                  double param2=100,
									int minRadius=0, 
                  int maxRadius=0 );
```

ç¬¬ä¸€ä¸ªå‚æ•°imageæ˜¯è¾“å…¥å›¾åƒçŸ©é˜µï¼Œè¦æ±‚æ˜¯ç°åº¦å›¾åƒï¼›

ç¬¬äºŒä¸ªå‚æ•° circlesæ˜¯ä¸€ä¸ªåŒ…å«æ£€æµ‹åˆ°çš„åœ†çš„ä¿¡æ¯çš„å‘é‡ï¼Œå‘é‡å†…ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åœ†çš„æ¨ªåæ ‡ï¼Œç¬¬äºŒä¸ªæ˜¯çºµåæ ‡ï¼Œç¬¬ä¸‰ä¸ªæ˜¯åŠå¾„å¤§å°ï¼›

ç¬¬ä¸‰ä¸ªå‚æ•° methodmethodæ˜¯æ‰€ä½¿ç”¨çš„åœ†æ£€æµ‹ç®—æ³•ï¼Œç›®å‰åªæœ‰CV_HOUGH_GRADIENTä¸€ä¸ªå¯é€‰ï¼›

ç¬¬å››ä¸ªå‚æ•° dpæ˜¯ç´¯åŠ é¢ä¸åŸå§‹å›¾åƒç›¸æ¯”çš„åˆ†è¾¨ç‡çš„åæ¯”å‚æ•°ï¼Œdp=2æ—¶ç´¯è®¡é¢åˆ†è¾¨ç‡æ˜¯å…ƒç´ å›¾åƒçš„ä¸€åŠï¼Œå®½é«˜éƒ½ç¼©å‡ä¸ºåŸæ¥çš„ä¸€åŠï¼Œdp=1æ—¶ï¼Œä¸¤è€…ç›¸åŒã€‚ï¼ˆå…³äºè¿™ä¸ªåˆ†è¾¨ç‡çš„æ¦‚å¿µæ²¡æœ‰ç†è§£é€ï¼ŒæŒ‰é“ç†ä½åˆ†è¾¨ç‡åº”è¯¥æ„å‘³ç€æ›´å¿«çš„æ£€æµ‹é€Ÿåº¦ï¼Œç„¶è€Œå®æµ‹æ°æ°ç›¸åï¼‰

ç¬¬äº”ä¸ªå‚æ•° minDistå®šä¹‰äº†ä¸¤ä¸ªåœ†å¿ƒä¹‹é—´çš„æœ€å°è·ç¦»ï¼›

ç¬¬å…­ä¸ªå‚æ•°param1æ˜¯Cannyè¾¹ç¼˜æ£€æµ‹çš„é«˜é˜ˆå€¼ï¼Œä½é˜ˆå€¼è¢«è‡ªåŠ¨ç½®ä¸ºé«˜é˜ˆå€¼çš„ä¸€åŠï¼›

ç¬¬ä¸ƒä¸ªå‚æ•°param2æ˜¯ç´¯åŠ å¹³é¢å¯¹æ˜¯å¦æ˜¯åœ†çš„åˆ¤å®šé˜ˆå€¼ï¼›

ç¬¬å…«å’Œç¬¬ä¹ä¸ªå‚æ•°å®šä¹‰äº†æ£€æµ‹åˆ°çš„åœ†çš„åŠå¾„çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼›



#### è¾¹ç¼˜æ£€æµ‹

[æ±‚å¯¼çš„ä¸€äº›ä»‹ç»](https://blog.csdn.net/kakiebu/article/details/79362576?ops_request_misc=%7B%22request%5Fid%22%3A%22158805933119195162532436%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=158805933119195162532436&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-2)

[å›¾åƒä¸€é˜¶å¯¼æ•°oräºŒé˜¶å¯¼æ•°](https://blog.csdn.net/du_shuang/article/details/82932546)

ä¸€èˆ¬æ¥è¯´ï¼Œå½“æˆ‘ä»¬æƒ³è¦è·å–å›¾åƒçš„è¾¹ç¼˜æ—¶ï¼Œé¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯åƒç´ å€¼å‘ç”Ÿçªå˜çš„ä½ç½®ï¼Œè€Œå¦‚ä½•ç”¨æ•°å­¦è¡¨è¾¾æ¥åˆ»ç”»"çªå˜"ï¼Œä¸€ä¸ªå¾ˆå¥½çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨å¯¼æ•°ï¼Œè€Œåœ¨å›¾åƒä¸­ï¼Œç”±äºåƒç´ æ˜¯ç¦»æ•£çš„ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨å·®åˆ†æ¥è¿‘ä¼¼å¤„ç†ï¼Œä½¿ç”¨æŸç§ç®—å­æ¥è¿‘ä¼¼è®¡ç®—å…¨å›¾æ¯ä¸€ç‚¹çš„æ¢¯åº¦å€¼ï¼Œå…¶ä¸­æ¢¯åº¦æ˜æ˜¾å¤§äºé‚»è¿‘åƒç´ çš„ç‚¹å°±è¢«è®¤ä¸ºæ˜¯è¾¹ç¼˜(å®é™…å¤„ç†ä¸­ï¼Œä½¿ç”¨å¤§äºæŸä¸€é˜ˆå€¼ä½œä¸ºè¯„åˆ¤æ ‡å‡†)

è¾¹ç¼˜æ£€æµ‹ä¸€èˆ¬æ­¥éª¤ï¼š

1. æ»¤æ³¢ ï¼š è¾¹ç¼˜æ£€æµ‹çš„ç®—æ³•ä¸»è¦æ˜¯åŸºäºå›¾åƒå¼ºåº¦çš„ä¸€é˜¶å’ŒäºŒé˜¶å¯¼æ•°ï¼Œ**ä½†å¯¼æ•°é€šå¸¸å¯¹å™ªå£°å¾ˆæ•æ„Ÿï¼Œå› æ­¤å¿…é¡»é‡‡ç”¨æ»¤æ³¢å™¨æ¥ï¼Œ æ”¹å–„ä¸å™ªå£°**æœ‰å…³çš„è¾¹ç¼˜æ£€æµ‹å™¨çš„æ€§èƒ½ã€‚å¸¸è§çš„æ»¤æ³¢æ–¹æ³•ä¸»è¦æœ‰é«˜æ–¯æ»¤æ³¢ï¼Œ å³é‡‡ç”¨ç¦»æ•£åŒ–çš„é«˜æ–¯å‡½æ•°äº§ç”Ÿä¸€ç»„å½’ä¸€åŒ–çš„é«˜æ–¯æ ¸ï¼ˆå…·ä½“è§â€œé«˜æ–¯æ»¤æ³¢åŸç†åŠå…¶ç¼–ç¨‹ç¦»æ•£åŒ–å®ç°æ–¹æ³•â€ä¸€æ–‡ï¼‰ï¼Œç„¶ååŸºäºé«˜æ–¯æ ¸å‡½æ•°å¯¹å›¾åƒç°åº¦çŸ©é˜µçš„æ¯ä¸€ç‚¹è¿›è¡ŒåŠ æƒæ±‚å’Œ
2. å¢å¼º ï¼š å¢å¼ºè¾¹ç¼˜çš„åŸºç¡€æ˜¯ç¡®å®šå›¾åƒå„ç‚¹é‚»åŸŸå¼ºåº¦çš„å˜åŒ–å€¼ã€‚å¢å¼ºç®—æ³•å¯ä»¥å°†å›¾åƒç°åº¦ç‚¹é‚»åŸŸå¼ºåº¦å€¼æœ‰æ˜¾è‘—å˜åŒ–çš„ç‚¹å‡¸æ˜¾å‡ºæ¥ã€‚åœ¨å…·ä½“ç¼–ç¨‹å®ç°æ—¶ï¼Œå¯é€šè¿‡è®¡ç®—æ¢¯åº¦å¹…å€¼æ¥ç¡®å®š
3. æ£€æµ‹ ï¼š ç»è¿‡å¢å¼ºçš„å›¾åƒï¼Œå¾€å¾€é‚»åŸŸä¸­æœ‰å¾ˆå¤šç‚¹çš„æ¢¯åº¦å€¼æ¯”è¾ƒå¤§ï¼Œè€Œåœ¨ç‰¹å®šçš„åº”ç”¨ä¸­ï¼Œè¿™äº›ç‚¹å¹¶ä¸æ˜¯æˆ‘ä»¬è¦æ‰¾çš„è¾¹ç¼˜ç‚¹ï¼Œæ‰€ä»¥åº”è¯¥é‡‡ç”¨æŸç§æ–¹æ³•æ¥å¯¹è¿™äº›ç‚¹è¿›è¡Œå–èˆã€‚å®é™…å·¥ç¨‹ä¸­ï¼Œå¸¸ç”¨çš„æ–¹æ³•æ˜¯é€šè¿‡é˜ˆå€¼åŒ–æ–¹æ³•æ¥æ£€æµ‹



**ä¸€é˜¶å¯¼æ•°å’ŒäºŒé˜¶å¯¼æ•°**

**è¨ˆç®—ä¸€éšå°æ•¸**

è¨±å¤šé‚Šç·£æª¢æ¸¬æ“ä½œéƒ½æ˜¯åŸºæ–¼äº®åº¦çš„ä¸€éš[å°æ•¸](https://zh.wikipedia.org/wiki/å¯¼æ•°)â€”â€”é€™æ¨£å°±å¾—åˆ°äº†åŸå§‹è³‡æ–™äº®åº¦çš„[æ¢¯åº¦](https://zh.wikipedia.org/w/index.php?title=Image_gradient&action=edit&redlink=1)ã€‚ä½¿ç”¨é€™å€‹è³‡è¨Šæˆ‘å€‘èƒ½å¤ åœ¨åœ–åƒçš„äº®åº¦æ¢¯åº¦ä¸­æœå°‹å³°å€¼ã€‚

å¦‚æœ*I*ï¼ˆ*x*ï¼‰ è¡¨ç¤ºé»*x*çš„äº®åº¦ï¼Œ*I*â€²ï¼ˆ*x*ï¼‰ è¡¨ç¤ºé»*x*çš„ä¸€éšå°æ•¸ï¼ˆäº®åº¦æ¢¯åº¦ï¼‰ï¼Œé€™æ¨£æˆ‘å€‘å°±æœƒç™¼ç¾ï¼š

$I'(x) = -1/2 * I(x-1) + 0 *I (x) + 1/2 * I(x+1)$

å°æ–¼æ›´é«˜æ•ˆèƒ½çš„åœ–åƒè™•ç†ä¾†èªªï¼Œ**ä¸€éšå°æ•¸èƒ½å¤ é€šéå¸¶æœ‰é®ç½©çš„åŸå§‹è³‡æ–™ï¼ˆ1ç¶­ï¼‰[å·ç©](https://zh.wikipedia.org/wiki/å·ç§¯)è¨ˆç®—å¾—åˆ°**

[âˆ’1/2,  0,  1/2]

**è¨ˆç®—äºŒéšå°æ•¸**

å…¶å®ƒä¸€äº›é‚Šç·£æª¢æ¸¬æ“ä½œæ˜¯åŸºæ–¼äº®åº¦çš„äºŒéšå°æ•¸ã€‚é€™å¯¦è³ªä¸Šæ˜¯äº®åº¦æ¢¯åº¦çš„[è®ŠåŒ–ç‡](https://zh.wikipedia.org/w/index.php?title=å˜åŒ–ç‡&action=edit&redlink=1)ã€‚åœ¨ç†æƒ³çš„é€£çºŒè®ŠåŒ–æƒ…æ³ä¸‹ï¼Œåœ¨äºŒéšå°æ•¸ä¸­æª¢æ¸¬éé›¶é»å°‡å¾—åˆ°æ¢¯åº¦ä¸­çš„å±€éƒ¨æœ€å¤§å€¼ã€‚å¦ä¸€æ–¹é¢ï¼ŒäºŒéšå°æ•¸ä¸­çš„å³°å€¼æª¢æ¸¬æ˜¯é‚Šç·šæª¢æ¸¬ï¼Œåªè¦åœ–åƒæ“ä½œä½¿ç”¨ä¸€å€‹åˆé©çš„å°ºåº¦è¡¨ç¤ºã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œé‚Šç·šæ˜¯é›™é‡é‚Šç·£ï¼Œé€™æ¨£æˆ‘å€‘å°±å¯ä»¥åœ¨é‚Šç·šçš„ä¸€é‚Šçœ‹åˆ°ä¸€å€‹äº®åº¦æ¢¯åº¦ï¼Œè€Œåœ¨å¦ä¸€é‚Šçœ‹åˆ°ç›¸åçš„æ¢¯åº¦ã€‚é€™æ¨£å¦‚æœåœ–åƒä¸­æœ‰é‚Šç·šå‡ºç¾çš„è©±æˆ‘å€‘å°±èƒ½åœ¨äº®åº¦æ¢¯åº¦ä¸Šçœ‹åˆ°éå¸¸å¤§çš„è®ŠåŒ–ã€‚ç‚ºäº†æ‰¾åˆ°é€™äº›é‚Šç·šï¼Œæˆ‘å€‘å¯ä»¥åœ¨åœ–åƒäº®åº¦æ¢¯åº¦çš„äºŒéšå°æ•¸ä¸­å°‹æ‰¾éé›¶é»ã€‚

å¦‚æœ*I*ï¼ˆ*x*ï¼‰ è¡¨ç¤ºé»*x*çš„äº®åº¦ï¼Œ*I*â€²â€²ï¼ˆ*x*ï¼‰ è¡¨ç¤ºé»*x*äº®åº¦çš„äºŒéšå°æ•¸ï¼Œé‚£éº¼ï¼š

$I'(x) = 1 * I(x-1)  -2 *I (x) + 1 * I(x+1)$

åŒæ¨£ï¼Œè¨±å¤šæ¼”ç®—æ³•ä¹Ÿä½¿ç”¨[å·ç©](https://zh.wikipedia.org/wiki/å·ç§¯)é®ç½©å¿«é€Ÿè™•ç†åœ–åƒè³‡æ–™ï¼š



[+1, âˆ’2, +1]



**Cannyç®—æ³•**

cannyç®—å­æ˜¯ä¸€ç§æ›´ç³»ç»Ÿæ€§çš„è¾¹ç¼˜æ£€æµ‹ç®—å­ï¼Œå…¶ä½¿ç”¨sobelç®—å­ä½œä¸ºæ£€æµ‹å™¨çš„è¡¥ä¸€ä»½ï¼ŒåŒæ—¶é¦–å…ˆä½¿ç”¨gaussæ»¤æ³¢å™¨å‡å¼±å™ªå£°çš„å½±å“ï¼Œæå–å‡ºè¾¹ç¼˜ä¹‹åå†ç”¨NMS(éæå¤§å€¼æŠ‘åˆ¶)å’Œé˜ˆå€¼ç­›é€‰æ¥å‡å°‘è™šå‡è¾¹ç¼˜ï¼Œè¿™é‡Œæˆ‘ä¸»è¦æ¶‰åŠå…¶ä¸­çš„éæå¤§å€¼æŠ‘åˆ¶éƒ¨åˆ†ã€‚

åœ¨ç›®æ ‡æ£€æµ‹ä»»åŠ¡ä¸­å¯¹æ£€æµ‹æ¡†NMSå·²ç»æ˜¯ä¸€ä¸ªå®¶å–»æˆ·æ™“çš„åŸºæœ¬æ“ä½œï¼Œä½†å…¶å®è¿™æ˜¯å›¾åƒå¤„ç†ç®—æ³•ä¸­çš„å¸¸ç”¨æŠ€å·§ã€‚cannyä¸­çš„éæå¤§å€¼æŠ‘åˆ¶ï¼Œå³è¦åœ¨sobelæå–å‡ºçš„æ¢¯åº¦å›¾ä¸­æ‰¾åˆ°æ¢¯åº¦çš„å±€éƒ¨æœ€å¤§å€¼ï¼Œå¹¶å°†éæå¤§å€¼ç½®ä¸º0ï¼Œä»è€Œå‡å°‘è™šæ£€ã€‚è€Œcannyä¸­çš„NMSæ˜¯æŒ‡æ˜¯å¦ä¸ºæ¢¯åº¦æ–¹å‘ä¸Šçš„æå¤§å€¼ï¼Œä¸åƒè§’ç‚¹æ£€æµ‹ç­‰åœºæ™¯ä¸‹æ˜¯å…¶é‚»åŸŸä¸­çš„æœ€å¤§å€¼ã€‚å…·ä½“çš„ç®—æ³•æ­¥éª¤å¦‚ä¸‹ï¼š

- å¯¹sobelæå–çš„å‚ç›´å’Œæ°´å¹³æ–¹å‘çš„ç»“æœä½¿ç”¨åæ­£åˆ‡çš„è¿‘ä¼¼è·å¾—æ¢¯åº¦æ–¹å‘
- æ ¹æ®æ¢¯åº¦æ–¹å‘åœ¨æ»¤æ³¢å™¨èŒƒå›´å†…æ‰¾åˆ°ä¸¤ä¸ªé‚»è¿‘çš„äºšåƒç´ ç‚¹(sub-pixel)
- ä½¿ç”¨åŒçº¿æ€§æ’å€¼è·å¾—è¿™ä¸¤ä¸ªäºšåƒç´ ç‚¹çš„æ¢¯åº¦ä¼°è®¡å€¼
- å°†ä¸¤ä¸ªä¼°è®¡å€¼å’Œå½“å‰ç‚¹çš„æ¢¯åº¦ç›¸æ¯”è¾ƒï¼Œè‹¥ä¸æ˜¯æå¤§å€¼ï¼Œåˆ™ç½®ä¸º0ï¼Œå¦åˆ™ä¿æŒä¸å˜

```c++
void Canny(InputArray image,OutputArray edges, double threshold1, double threshold2, int apertureSize=3,bool L2gradient=false )
```

ç¬¬ä¸€ä¸ªå‚æ•°ï¼ŒInputArrayç±»å‹çš„imageï¼Œè¾“å…¥å›¾åƒï¼Œå³æºå›¾åƒï¼Œå¡«Matç±»çš„å¯¹è±¡å³å¯ï¼Œä¸”éœ€ä¸ºå•é€šé“8ä½å›¾åƒã€‚
ç¬¬äºŒä¸ªå‚æ•°ï¼ŒOutputArrayç±»å‹çš„edgesï¼Œè¾“å‡ºçš„è¾¹ç¼˜å›¾ï¼Œéœ€è¦å’Œæºå›¾ç‰‡æœ‰ä¸€æ ·çš„å°ºå¯¸å’Œç±»å‹ã€‚
ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œdoubleç±»å‹çš„threshold1ï¼Œç¬¬ä¸€ä¸ªæ»åæ€§é˜ˆå€¼ã€‚
ç¬¬å››ä¸ªå‚æ•°ï¼Œdoubleç±»å‹çš„threshold2ï¼Œç¬¬äºŒä¸ªæ»åæ€§é˜ˆå€¼ã€‚
ç¬¬äº”ä¸ªå‚æ•°ï¼Œintç±»å‹çš„apertureSizeï¼Œè¡¨ç¤ºåº”ç”¨Sobelç®—å­çš„å­”å¾„å¤§å°ï¼Œå…¶æœ‰é»˜è®¤å€¼3ã€‚
ç¬¬å…­ä¸ªå‚æ•°ï¼Œboolç±»å‹çš„L2gradientï¼Œä¸€ä¸ªè®¡ç®—å›¾åƒæ¢¯åº¦å¹…å€¼çš„æ ‡è¯†ï¼Œæœ‰é»˜è®¤å€¼false

PS.è¿™ä¸ªå‡½æ•°é˜ˆå€¼1å’Œé˜ˆå€¼2ä¸¤è€…çš„å°è€…ç”¨äºè¾¹ç¼˜è¿æ¥ï¼Œè€Œå¤§è€…ç”¨æ¥æ§åˆ¶å¼ºè¾¹ç¼˜çš„åˆå§‹æ®µï¼Œæ¨èçš„é«˜ä½é˜ˆå€¼æ¯”åœ¨2:1åˆ°3:1ä¹‹é—´



**sobelç®—æ³•**

sobelç®—å­å°±æ˜¯å®ç°ä¸Šè¿°ç®—æ³•çš„ä¸€ç§åŸºæœ¬ç®—å­ï¼Œå…¶ä¸€èˆ¬åˆ†ä¸ºæ°´å¹³å’Œå‚ç›´ä¸¤ä¸ªæ–¹å‘çš„è®¡ç®—ï¼Œä¸¤ä¸ªæ–¹å‘ä¸Šçš„ç®—å­äº’ä¸ºè½¬ç½®ã€‚åœ¨ä¸¤ä¸ªæ–¹å‘åˆ†åˆ«è®¡ç®—å®Œæˆä¹‹åï¼Œå–å…¶ç»å¯¹å€¼çš„å’Œæˆ–å¹³æ–¹å’Œçš„ç®—æœ¯å¹³æ–¹æ ¹(1ï¼Œ2èŒƒæ•°)ï¼Œå³å¾—åˆ°æœ€ç»ˆçš„æ¢¯åº¦ç»“æœã€‚**(ä¸€èˆ¬æ¥è¯´åœ¨ç¡¬ä»¶ä¸Šè®¡ç®—ç»å¯¹å€¼è¦æ¯”å¹³æ–¹å¼€æ–¹å»‰ä»·å¾ˆå¤šï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨ç»å¯¹å€¼è¾ƒå¤š)**

```c++
C++: void Sobel (
InputArray src,//è¾“å…¥å›¾
 OutputArray dst,//è¾“å‡ºå›¾
 int ddepth,//è¾“å‡ºå›¾åƒçš„æ·±åº¦
 int dx,
 int dy,
 int ksize=3,
 double scale=1,
 double delta=0,
 int borderType=BORDER_DEFAULT );
```

éœ€è¦é’ˆå¯¹xåŠyæ–¹å‘åˆ†åˆ«è¿›è¡Œæ±‚æ¢¯åº¦



è¿˜éœ€è¦convertScaleAbsè½¬æ¢å‡½æ•°ï¼Œ ï¼ˆæŠŠæ±‚å¯¼åçš„ç»“æœéƒ½è½¬æˆæ­£æ•°ï¼Ÿï¼‰

é’ˆå¯¹è¾“å…¥çš„æ¯ä¸ªå…ƒç´  ä¹˜ä¸Šalpha + beta å–abs å¹¶è½¬æ¢ä¸ºint8

```c++
void cv::convertScaleAbs	(	InputArray 	src,
OutputArray 	dst,
double 	alpha = 1,
double 	beta = 0 
)	
```

æœ€ç»ˆåˆ©ç”¨addWeighted é’ˆå¯¹ä¸¤ä¸ªè¾“å…¥è¿›è¡Œæƒé‡åˆ†é…ç„¶åç›¸åŠ ï¼Œ è¯¥å‡½æ•°æ‰§è¡Œ $dst = src1*alpha + src2*beta + gamma;$

```c++
void cv::addWeighted	(	InputArray 	src1,
double 	alpha,
InputArray 	src2,
double 	beta,
double 	gamma,
OutputArray 	dst,
int 	dtype = -1 
)	
```





**scharrç®—æ³•**

```c++
void cv::Scharr	(	InputArray 	src,
OutputArray 	dst,
int 	ddepth,
int 	dx,
int 	dy,
double 	scale = 1,
double 	delta = 0,
int 	borderType = BORDER_DEFAULT 
)
```

æ£€æµ‹è¾¹ç¼˜çš„æ•ˆæœæ›´å¥½ï¼Œ ä¸»è¦è·Ÿsobelçš„åŒºåˆ«åœ¨äºå†…æ ¸æ•°å€¼ä¸åŒ



**Laplacianç®—æ³•**

<img src="https://www.zhihu.com/equation?tex=Laplace%28f%29%3D%5Cfrac%7B%5Cpartial%5E2f%7D%7B%5Cpartial+x%5E2%7D%2B%5Cfrac%7B%5Cpartial%5E2f%7D%7B%5Cpartial+y%5E2%7D">

sobelç®—å­å…·æœ‰æ˜ç¡®çš„æ–¹å‘æ€§(å‚ç›´å’Œæ°´å¹³)ï¼Œå°†å›¾åƒæ—‹è½¬æŸä¸€è§’åº¦ï¼Œå…¶æå–æ•ˆæœå°±ä¼šä¸‹é™ï¼Œä½†æ˜¯laplaceç®—å­å´æ˜¯å…·æœ‰æ—‹è½¬ä¸å˜æ€§çš„ï¼Œè¿™ä¸€ç‚¹å¯ä»å…¶æ¨¡æ¿ä¸­å¿ƒå¯¹ç§°æ€§ï¼Œæˆ–è€…ä»åŸå§‹å…¬å¼è¯æ˜å¾—åˆ°

ç”±äºlaplaceç®—å­ä½¿ç”¨äº†äºŒé˜¶å¯¼æ•°ï¼Œæ‰€ä»¥å…¶ç›¸æ¯”sobelè¿™ç§ä¸€é˜¶æ–¹æ³•å¯¹å™ªå£°æ›´æ•æ„Ÿï¼Œå…¶å—å™ªå£°çš„å½±å“æ›´æ˜æ˜¾ï¼ˆæƒ³è±¡ä¸€ä¸‹ä¸€æ¡å¹³æ»‘çš„å‡½æ•°å›¾åƒä¸Šå‡ºç°äº†å¾ˆå¤šé”¯é½¿æ®µï¼Œè¿™æ ·è‡ªç„¶ä¼šé”™è¯¯åœ°å‘ç°æ›´å¤šè™šå‡çš„æå€¼ç‚¹ï¼‰

```c++
void Laplacian(InputArray src,OutputArray dst, int ddepth, int ksize=1, double scale=1, double delta=0, intborderType=BORDER_DEFAULT );
```

ç¬¬ä¸€ä¸ªå‚æ•°ï¼ŒInputArrayç±»å‹çš„imageï¼Œè¾“å…¥å›¾åƒï¼Œå³æºå›¾åƒï¼Œå¡«Matç±»çš„å¯¹è±¡å³å¯ï¼Œä¸”éœ€ä¸ºå•é€šé“8ä½å›¾åƒã€‚
ç¬¬äºŒä¸ªå‚æ•°ï¼ŒOutputArrayç±»å‹çš„edgesï¼Œè¾“å‡ºçš„è¾¹ç¼˜å›¾ï¼Œéœ€è¦å’Œæºå›¾ç‰‡æœ‰ä¸€æ ·çš„å°ºå¯¸å’Œé€šé“æ•°ã€‚
ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œintç±»å‹çš„ddeptï¼Œç›®æ ‡å›¾åƒçš„æ·±åº¦ã€‚
ç¬¬å››ä¸ªå‚æ•°ï¼Œintç±»å‹çš„ksizeï¼Œç”¨äºè®¡ç®—äºŒé˜¶å¯¼æ•°çš„æ»¤æ³¢å™¨çš„å­”å¾„å°ºå¯¸ï¼Œå¤§å°å¿…é¡»ä¸ºæ­£å¥‡æ•°ï¼Œä¸”æœ‰é»˜è®¤å€¼1ã€‚
ç¬¬äº”ä¸ªå‚æ•°ï¼Œdoubleç±»å‹çš„scaleï¼Œè®¡ç®—æ‹‰æ™®æ‹‰æ–¯å€¼çš„æ—¶å€™å¯é€‰çš„æ¯”ä¾‹å› å­ï¼Œæœ‰é»˜è®¤å€¼1ã€‚
ç¬¬å…­ä¸ªå‚æ•°ï¼Œdoubleç±»å‹çš„deltaï¼Œè¡¨ç¤ºåœ¨ç»“æœå­˜å…¥ç›®æ ‡å›¾ï¼ˆç¬¬äºŒä¸ªå‚æ•°dstï¼‰ä¹‹å‰å¯é€‰çš„deltaå€¼ï¼Œæœ‰é»˜è®¤å€¼0ã€‚
ç¬¬ä¸ƒä¸ªå‚æ•°ï¼Œ intç±»å‹çš„borderTypeï¼Œè¾¹ç•Œæ¨¡å¼ï¼Œé»˜è®¤å€¼ä¸ºBORDER_DEFAULTã€‚è¿™ä¸ªå‚æ•°å¯ä»¥åœ¨å®˜æ–¹æ–‡æ¡£ä¸­borderInterpolate()å¤„å¾—åˆ°æ›´è¯¦ç»†çš„ä¿¡æ¯

#### Mask æ©è†œ

åœ¨æœ‰äº›å›¾åƒå¤„ç†çš„å‡½æ•°ä¸­æœ‰çš„å‚æ•°é‡Œé¢ä¼šæœ‰maskå‚æ•°ï¼Œå³æ­¤å‡½æ•°æ”¯æŒæ©è†œæ“ä½œ

```c++
void cv::inRange	(	InputArray 	src,
InputArray 	lowerb,
InputArray 	upperb,
OutputArray 	dst 
)	
```

inrangeç±»ä¼¼threshholdï¼Œ å¦‚æœä¸€å¹…ç°åº¦å›¾åƒçš„æŸä¸ªåƒç´ çš„ç°åº¦å€¼åœ¨æŒ‡å®šçš„é«˜ã€ä½é˜ˆå€¼èŒƒå›´ä¹‹å†…ï¼Œåˆ™åœ¨dstå›¾åƒä¸­ä»¤è¯¥åƒç´ å€¼ä¸º255ï¼Œå¦åˆ™ä»¤å…¶ä¸º0ï¼Œè¿™æ ·å°±ç”Ÿæˆäº†ä¸€å¹…äºŒå€¼åŒ–çš„è¾“å‡ºå›¾åƒ

é’ˆå¯¹ä¸‰é€šé“å›¾åƒ
dst(I) = lowerb(I)0 â‰¤ src(I)0 < upperb(I)0 âˆ§ lowerb(I)1 â‰¤ src(I)1 < upperb(I)1 âˆ§lowerb(I)2 â‰¤ src(I)2 < upperb(I)2
å³ï¼Œæ¯ä¸ªé€šé“çš„åƒç´ å€¼éƒ½å¿…é¡»åœ¨è§„å®šçš„é˜ˆå€¼èŒƒå›´å†…





#### å½¢æ€å­¦

ç»“æ„å…ƒç´ å¯ä»¥æ˜¯çŸ©å½¢/æ¤­åœ†/åå­—å½¢ï¼Œå¯ä»¥ç”¨`getStructuringElement()`æ¥ç”Ÿæˆä¸åŒå½¢çŠ¶çš„ç»“æ„å…ƒç´ , å°±æ˜¯äº§ç”Ÿä¸€ä¸ªå·ç§¯æ ¸è¿ç”¨åœ¨è†¨èƒ€æˆ–è€…è…èš€ä¸Š

```c++
Mat cv::getStructuringElement	(	int shape, Size 	ksize, Point 	anchor = Point(-1,-1))	
```

- shape : å…ƒç´ çš„å½¢çŠ¶[MorphShapes](https://docs.opencv.org/4.2.0/d4/d86/group__imgproc__filter.html#gac2db39b56866583a95a5680313c314ad)
- ksize ï¼šç»“æ„å…ƒç´ çš„å°ºå¯¸
- anchor ï¼š åœ¨å…ƒç´ ä¸­çš„anchorçš„ä½ç½®é¢„è®¾æ˜¯(-1, -1)è¡¨ç¤ºåœ¨æ­£ä¸­é—´ï¼Œ åªæœ‰crossshapeed elementå–å†³äºanchorçš„ä½ç½®ï¼Œ In other cases the anchor just regulates how much the result of the morphological operation is shifted

```c++
void cv::morphologyEx	(	InputArray 	src,
OutputArray 	dst,
int 	op,
InputArray 	kernel,
Point 	anchor = Point(-1,-1),
int 	iterations = 1,
int 	borderType = BORDER_CONSTANT,
const Scalar & 	borderValue = morphologyDefaultBorderValue() 
)	
```

Parameters

- src : source image
- Dst : ä¸sourceä¸€æ ·sizeçš„ç›®æ ‡å›¾åƒ
- op ï¼š å½¢æ€å­¦æ“ä½œï¼Œ è§ä¸‹é¢è¡¨æ ¼
- kernel ï¼š å°±æ˜¯åˆ©ç”¨getStructuringElement åˆ¶ä½œçš„kernel
- anchor ï¼š 
- iterationï¼šerosion or dilationçš„æ¬¡æ•°
- borderType ï¼š åƒç´ å¤–æ¨çš„æ–¹æ³•[BorderTypes](https://docs.opencv.org/4.2.0/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5)
- borderValue : è¾¹ç•Œå€¼ï¼Œ å¦‚æœè¾¹ç•Œæ˜¯ä¸ªå¸¸æ•°çš„è¯





å½¢æ€æ“ä½œç±»å‹

erosion https://www.youtube.com/watch?v=rP1KZb3llCY

Erosion åŠ¨ç”»è§£é‡Š https://www.youtube.com/watch?v=b5lgnNEzGeU

dailation åŠ¨ç”»å›¾è§£ https://www.youtube.com/watch?v=3IJ8RFtlDLY

| MORPH_ERODE Python: cv.MORPH_ERODE       | see [erode](https://docs.opencv.org/3.4.8/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb) |
| ---------------------------------------- | ------------------------------------------------------------ |
| MORPH_DILATE Python: cv.MORPH_DILATE     | see [dilate](https://docs.opencv.org/3.4.8/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c) |
| MORPH_OPEN Python: cv.MORPH_OPEN         | an opening operation ğšğšœğš=open(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)=dilate(erode(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)) |
| MORPH_CLOSE Python: cv.MORPH_CLOSE       | a closing operationğšğšœğš=close(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)=erode(dilate(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)) |
| MORPH_GRADIENT Python: cv.MORPH_GRADIENT | a morphological gradientğšğšœğš=morph_grad(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)=dilate(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)âˆ’erode(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš) |
| MORPH_TOPHAT Python: cv.MORPH_TOPHAT     | "top hat"ğšğšœğš=tophat(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)=ğšœğš›ğšŒâˆ’open(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)       |
| MORPH_BLACKHAT Python: cv.MORPH_BLACKHAT | "black hat"ğšğšœğš=blackhat(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)=close(ğšœğš›ğšŒ,ğšğš•ğšğš–ğšğš—ğš)âˆ’ğšœğš›ğšŒ  |
| MORPH_HITMISS Python: cv.MORPH_HITMISS   | "hit or miss" .- Only supported for CV_8UC1 binary images. A tutorial can be found in the documentation |





#### è½®å»“

##### æ‰¾å‡ºè½®å»“

**ref** : https://blog.csdn.net/asukasmallriver/article/details/76718701

åŸºäºäºŒå€¼å›¾æˆ–è€…æ˜¯ç°åº¦å›¾ è¿›è¡Œè½®å»“æŸ¥æ‰¾ï¼Œ æ‰¾åˆ°çš„è½®å»“å°†ä»¥ç‚¹é›†åˆçš„æ–¹å¼å­˜å‚¨åœ¨å®¹å™¨ä¸­

ä¸»è¦éœ€è¦ç†Ÿæ‚‰contours çš„å­˜å‚¨æ–¹å¼

```c++
void cv::findContours	(	InputArray 	image,
OutputArrayOfArrays 	contours,
OutputArray 	hierarchy,
int 	mode,
int 	method,
Point 	offset = Point() 
)	
```

- image : source image äºŒå€¼å›¾
- contours ï¼š æ‰¾åˆ°çš„è½®å»“ï¼Œ å­˜å‚¨çš„æ–¹å¼ä¸º`vector< vector<Point> >`, pointå­˜å‚¨çš„å°±æ˜¯å±äºè¿™ä¸ªè½®å»“çš„åæ ‡ï¼Œ vector å­˜å‚¨å±äºè¿™ä¸ªè½®å»“çš„æ‰€æœ‰åæ ‡ç‚¹ï¼Œ å¤–åœˆvectorå­˜å‚¨æ‰€æœ‰çš„è½®å»“
- hierachy ï¼šå­˜å‚¨åœ¨ `vector<Vec4i>`  åˆ†åˆ«è¡¨ç¤ºç¬¬ iä¸ªè½®å»“çš„**å****ä¸€ä¸ªè½®å»“ã€å‰ä¸€ä¸ªè½®å»“ã€çˆ¶è½®å»“ã€å†…åµŒè½®å»“çš„ç´¢å¼•ç¼–å·**ã€‚å¦‚æœå½“å‰è½®å»“æ²¡æœ‰å¯¹åº”çš„åä¸€ä¸ªè½®å»“ã€å‰ä¸€ä¸ªè½®å»“ã€çˆ¶è½®å»“æˆ–å†…åµŒè½®å»“çš„è¯ï¼Œåˆ™hierarchy[i][0] ~hierarchy[i][3]çš„ç›¸åº”ä½è¢«è®¾ç½®ä¸ºé»˜è®¤å€¼-1
- mode ï¼šè½®å»“è·å–çš„æ¨¡å¼ å‚è€ƒhttps://docs.opencv.org/3.4.8/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71
- method ï¼šè½®å»“è¿‘ä¼¼çš„æ–¹æ³•ï¼Œ ç”¨æœ€å°‘çš„é¡¶ç‚¹è¿æˆå½¢çŠ¶[ContourApproximationModes](https://docs.opencv.org/4.2.0/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff)
- Offset : è®¾ç½®è½®å»“çš„ç‚¹çš„åç§»å€¼ï¼Œ å½“è½®å»“ä»imageçš„roiæ‰¾å‡ºæ¥ï¼Œ ä½†éœ€è¦ä»æ•´å¼ å›¾æ¥åˆ†æçš„æ—¶å€™





##### è½®å»“çš„é¢ç§¯

```c++
double cv::contourArea	(	InputArray 	contour,
bool 	oriented = false 
)	
```

è®¡ç®—å‡ºcontourçš„é¢ç§¯



##### ç”»å‡ºè½®å»“

è—‰ç”±æ‰¾åˆ°çš„è½®å»“ç‚¹é›†ï¼Œ å¯ä»¥åœ¨å›¾åƒä¸Šç”»å‡ºè½®å»“çº¿æ¡

```c++
void cv::drawContours	(	InputOutputArray 	image,
        InputArrayOfArrays 	contours,
        int 	contourIdx,
        const Scalar & 	color,
        int 	thickness = 1,
        int 	lineType = LINE_8,
        InputArray 	hierarchy = noArray(),
        int 	maxLevel = INT_MAX,
        Point 	offset = Point() 
)	
```

thickness å¦‚æœå¡«å…¥FILLEDçš„è¯ï¼Œ è½®å»“å†…ä¼šè¢«å¡«æ»¡é¢œè‰²







##### ç”»å‡ºè¾¹ç•Œæ¡†

ä¼ å…¥æ‰¾åˆ°çš„è½®å»“ç‚¹é›†ï¼Œ å¯ä»¥æ‰¾åˆ°æœ€å°çŸ©å½¢æ¡†ï¼Œ return ä¸€ä¸ªRect ç±»å‹

```c++
Rect cv::boundingRect	(	InputArray 	array	)	
```

æ‰¾åˆ°å¯ä»¥ç”¨æœ€å°çŸ©å½¢æ¡†å‡ºç‰©ä½“çš„ï¼ˆx, y, w, h)

- array :è¾“å…¥ç°åº¦å›¾ æˆ–è€… 2dç‚¹é›†åˆï¼ˆvector or matï¼‰



example

```c++
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
using namespace cv;
using namespace std;
int main( int argc, char** argv )
{
    Mat src;
    // the first command-line parameter must be a filename of the binary
    // (black-n-white) image
    if( argc != 2 || !(src=imread(argv[1], 0)).data)
        return -1;
    Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC3);
    src = src > 1;
    namedWindow( "Source", 1 );
    imshow( "Source", src );
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    findContours( src, contours, hierarchy,
        RETR_CCOMP, CHAIN_APPROX_SIMPLE );
    // iterate through all the top-level contours,
    // draw each connected component with its own random color
    int idx = 0;
    for( ; idx >= 0; idx = hierarchy[idx][0] )
    {
        Scalar color( rand()&255, rand()&255, rand()&255 );
        drawContours( dst, contours, idx, color, FILLED, 8, hierarchy );
    }
    namedWindow( "Components", 1 );
    imshow( "Components", dst );
    waitKey(0);
}
```



##### æœ€å°å¤šè¾¹å½¢/é¡¶ç‚¹é€¼è¿‘è½®å»“

ä¼ å…¥æ‰¾åˆ°çš„è½®å»“ï¼Œ ç®—æ³•å…ˆä»è½®å»“é€‰æ‹©2ä¸ªæœ€è¿œçš„ç‚¹ï¼Œç„¶åå°†2ä¸ªè¿æˆä¸€ä¸ªçº¿æ®µï¼Œç„¶åå†æŸ¥æ‰¾è½®å»“ä¸Šåˆ°çº¿æ®µè·ç¦»æœ€è¿œçš„ç‚¹ï¼Œæ·»åŠ åˆ°é€¼è¿‘åçš„æ–°è½®å»“ã€‚ç®—æ³•åå¤è¿­ä»£ï¼Œä¸æ–­å°†æœ€è¿œçš„ç‚¹æ·»åŠ åˆ°ç»“æœä¸­ã€‚ç›´åˆ°æ‰€æœ‰çš„ç‚¹åˆ°å¤šè¾¹å½¢çš„æœ€çŸ­è·ç¦»å°äºparameterå‚æ•°æŒ‡å®šçš„ç²¾åº¦ã€‚

C++

```c++
void cv::approxPolyDP	(	InputArray 	curve,
    OutputArray 	approxCurve,
    double 	epsilon,
    bool 	closed 
    )	
```

C

```c
CvSeq* cvApproxPoly(const void* src_seq, int header_size, CvMemStorage* storage, int method, double eps, int recursive=0 )
```









#### å›¾åƒåˆ†å‰²

```c++
void cv::grabCut	(	InputArray 	img,
InputOutputArray 	mask,
Rect 	rect,
InputOutputArray 	bgdModel,
InputOutputArray 	fgdModel,
int 	iterCount,
int 	mode = GC_EVAL 
)
```

- img : soruce img
- mask : single channel mask (ROIåŒºåŸŸçš„mask)
- Rect : 
- bdgModel : ä¸´æ—¶èƒŒæ™¯æ¨¡å‹æ•°ç»„
- fgdModel ï¼š ä¸´æ—¶å‰æ™¯æ¨¡å‹æ•°ç»„
- interCount ï¼š æŒ‡å®šå¤šå°‘å°±ç­‰äº 13ä¹˜ä»¥å¤šå°‘
- mode : 

| img       | Input 8-bit 3-channel image.                                 |
| --------- | ------------------------------------------------------------ |
| mask      | Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to [GC_INIT_WITH_RECT](https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#ggaf8b5832ba85e59fc7a98a2afd034e558a5f8853c1e5a89c4aa2687d1f78a7e550). Its elements may have one of the [GrabCutClasses](https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#gad43d3e4208d3cf025d8304156b02ba38). |
| rect      | ROI containing a segmented object. The pixels outside of the ROI are marked as "obvious background". The parameter is only used when mode==[GC_INIT_WITH_RECT](https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#ggaf8b5832ba85e59fc7a98a2afd034e558a5f8853c1e5a89c4aa2687d1f78a7e550) . |
| bgdModel  | Temporary array for the background model. Do not modify it while you are processing the same image. |
| fgdModel  | Temporary arrays for the foreground model. Do not modify it while you are processing the same image. |
| iterCount | Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==[GC_INIT_WITH_MASK](https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#ggaf8b5832ba85e59fc7a98a2afd034e558ab01527c7effb50fd1c54d8c4e671ed22) or mode==GC_EVAL . |
| mode      | Operation mode that could be one of the [GrabCutModes](https://docs.opencv.org/3.4/d7/d1b/group__imgproc__misc.html#gaf8b5832ba85e59fc7a98a2afd034e558) |





#### ç‰¹å¾æ£€æµ‹

https://www.cnblogs.com/skyfsm/p/7401523.html

ä¸€ç§å¯è¡Œçš„æ–¹æ³•æ˜¯æ‰¾å‡º2å¼ å›¾ç‰‡ä¸­çš„ç‰¹å¾ç‚¹ï¼Œæè¿°è¿™äº›ç‰¹å¾ç‚¹çš„å±æ€§ï¼Œç„¶åæ¯”è¾ƒè¿™ä¸¤å¹…å›¾ç‰‡çš„ç‰¹å¾ç‚¹çš„å±æ€§ã€‚å¦‚æœæœ‰è¶³å¤Ÿå¤šçš„ç‰¹å¾ç‚¹å…·æœ‰ç›¸åŒçš„å±æ€§

å›¾åƒçš„ç‰¹å¾ç‚¹å¯ä»¥ç®€å•çš„ç†è§£ä¸ºå›¾åƒä¸­æ¯”è¾ƒæ˜¾è‘—çš„ç‚¹ï¼Œå¦‚è½®å»“ç‚¹ï¼Œè¾ƒæš—åŒºåŸŸä¸­çš„äº®ç‚¹ï¼Œè¾ƒäº®åŒºåŸŸä¸­çš„æš—ç‚¹ç­‰

openCV 3.xä¹‹åçš„ç‰ˆæœ¬ï¼Œ å„ç§ç‰¹å¾æ£€æµ‹è°ƒç”¨çš„æ–¹æ³•

```c++
cv::xfeatures2d::SURF
cv::xfeatures2d::SIFT
cv::xfeatures::BriefDescriptorExtractor
cv::xfeatures2d::FREAK
cv::xfeatures2d::StarDetector
```

**SIFT ç‰¹å¾å…³é”®ç‚¹æ£€æµ‹**



**SURFç‰¹å¾å…³é”®ç‚¹æ£€æµ‹**

å¿…é¡»åŒ…å«ä»¥ä¸‹å¤´æ–‡ä»¶

```c++
#include <opencv2/xfeatures2d/nonfree.hpp>

using namespace cv::xfeatures2d;
```

ä½¿ç”¨çš„ä¾‹å­

```c++
std::vector<KeyPoint> keyPoints_1, keyPoints_2;
int minHessian = 700;
// æµ·å¡çŸ©é˜µé˜ˆå€¼ï¼Œåœ¨è¿™é‡Œè°ƒæ•´ç²¾åº¦ï¼Œå€¼è¶Šå¤§ç‚¹è¶Šå°‘ï¼Œè¶Šç²¾å‡†
Ptr<SURF>detector = SURF::create(minHessian); //æ™ºèƒ½æŒ‡é’ˆåˆ›å»ºsurf detector
//ã€3ã€‘è°ƒç”¨detectå‡½æ•°æ£€æµ‹å‡ºSURFç‰¹å¾å…³é”®ç‚¹ï¼Œä¿å­˜åœ¨vectorå®¹å™¨ä¸­
detector->detect( image1, keyPoints_1 );

detector->detect( image2, keyPoints_2 );

Mat img_keypoints_1; Mat img_keypoints_2;

//å°†æ‰¾åˆ°çš„å…³é”®ç‚¹ç»˜åˆ¶åœ¨img_keypoints_1ä¸Š
drawKeypoints( image1, keyPoints_1, img_keypoints_1, Scalar::all(-1), DrawMatchesFlags::DEFAULT );
drawKeypoints( image2, keyPoints_2, img_keypoints_2, Scalar::all(-1), DrawMatchesFlags::DEFAULT );
```

**Fast ç‰¹å¾å…³é”®ç‚¹æ£€æµ‹**

æ¯”sift, surféƒ½æ¥çš„å¿«é€Ÿ

```c++
vector<KeyPoint>detectKeyPoint;
Mat keyPointImage1,keyPointImage2;

Ptr<FastFeatureDetector> fast = FastFeatureDetector::create();
fast->detect(srcGrayImage,detectKeyPoint);
drawKeypoints(srcImage,detectKeyPoint,keyPointImage1,Scalar(0,0,255),DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
drawKeypoints(srcImage,detectKeyPoint,keyPointImage2,Scalar(0,0,255),DrawMatchesFlags::DEFAULT);

imshow("src image",srcImage);
imshow("keyPoint image1",keyPointImage1);
imshow("keyPoint image2",keyPointImage2);
```









**ORB ç‰¹å¾å…³é”®ç‚¹æ£€æµ‹**

Oriented Fast and Rotated BRIEF

ORBé‡‡ç”¨FASTï¼ˆfeatures from accelerated segment testï¼‰ç®—æ³•æ¥æ£€æµ‹ç‰¹å¾ç‚¹ã€‚FAST**æ ¸å¿ƒæ€æƒ³**å°±æ˜¯æ‰¾å‡ºé‚£äº›å“å°”ä¸ç¾¤çš„ç‚¹ï¼Œå³æ‹¿ä¸€ä¸ªç‚¹è·Ÿå®ƒå‘¨å›´çš„ç‚¹æ¯”è¾ƒï¼Œå¦‚æœå®ƒå’Œå…¶ä¸­å¤§éƒ¨åˆ†çš„ç‚¹éƒ½ä¸ä¸€æ ·å°±å¯ä»¥è®¤ä¸ºå®ƒæ˜¯ä¸€ä¸ªç‰¹å¾ç‚¹

**FASTå…·ä½“è®¡ç®—è¿‡ç¨‹ï¼š**

1. ä»å›¾ç‰‡ä¸­é€‰å–ä¸€ä¸ªåƒç´ ç‚¹Pï¼Œä¸‹é¢æˆ‘ä»¬å°†åˆ¤æ–­å®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªç‰¹å¾ç‚¹ã€‚æˆ‘ä»¬é¦–å…ˆæŠŠå®ƒçš„å¯†åº¦ï¼ˆå³ç°åº¦å€¼ï¼‰è®¾ä¸ºIpã€‚
2. è®¾å®šä¸€ä¸ªåˆé€‚çš„é˜™å€¼t ï¼šå½“2ä¸ªç‚¹çš„ç°åº¦å€¼ä¹‹å·®çš„ç»å¯¹å€¼å¤§äºtæ—¶ï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™2ä¸ªç‚¹ä¸ç›¸åŒã€‚
3. è€ƒè™‘è¯¥åƒç´ ç‚¹å‘¨å›´çš„16ä¸ªåƒç´ ã€‚ï¼ˆè§ä¸Šå›¾ï¼‰
4. ç°åœ¨å¦‚æœè¿™16ä¸ªç‚¹ä¸­æœ‰è¿ç»­çš„nä¸ªç‚¹éƒ½å’ŒPç‚¹ä¸åŒï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªè§’ç‚¹ã€‚ è¿™é‡Œnè®¾å®šä¸º12ã€‚
5. ã€ä¸ªäººè®¤ä¸ºä½œè€…è¿™ä¸ªæ–¹æ³•æœ‰é—®é¢˜ã€‘æˆ‘ä»¬ç°åœ¨æå‡ºä¸€ä¸ªé«˜æ•ˆçš„ï¼Œæ¥å¿«é€Ÿæ’é™¤ä¸€å¤§éƒ¨åˆ†éç‰¹å¾ç‚¹çš„ç‚¹ã€‚è¯¥æµ‹è¯•ä»…ä»…æ£€æŸ¥åœ¨ä½ç½®1ã€9ã€5å’Œ13å››ä¸ªä½ç½®çš„åƒç´ ï¼ˆé¦–å…ˆæ£€æŸ¥1å’Œ9ï¼Œçœ‹å®ƒä»¬æ˜¯å¦å’ŒPç‚¹ç›¸åŒã€‚å¦‚æœæ˜¯ï¼Œå†æ£€æŸ¥5å’Œ13ï¼‰ã€‚å¦‚æœæ˜¯ä¸€ä¸ªè§’ç‚¹ï¼Œé‚£ä¹ˆä¸Šè¿°å››ä¸ªåƒç´ ç‚¹ä¸­è‡³å°‘æœ‰3ä¸ªåº”è¯¥å’ŒPç‚¹ç›¸åŒã€‚å¦‚æœéƒ½ä¸æ»¡è¶³ï¼Œé‚£ä¹ˆä¸å¯èƒ½æ˜¯ä¸€ä¸ªè§’ç‚¹



ä½¿ç”¨æ–¹æ³•



```c++
static Ptr<ORB> cv::ORB::create	(	int 	nfeatures = 500,
float 	scaleFactor = 1.2f,
int 	nlevels = 8,
int 	edgeThreshold = 31,
int 	firstLevel = 0,
int 	WTA_K = 2,
int 	scoreType = ORB::HARRIS_SCORE,
int 	patchSize = 31,
int 	fastThreshold = 20 
)	
```



#### å›¾åƒæ‹¼æ¥

ä½¿ç”¨äºŒç»´ç‰¹å¾ç‚¹(Features2D)å’Œå•æ˜ å°„(Homography)å¯»æ‰¾å·²çŸ¥ç‰©ä½“

```c++
Mat cv::findHomography	(	InputArray 	srcPoints,
InputArray 	dstPoints,
int 	method = 0,
double 	ransacReprojThreshold = 3,
OutputArray 	mask = noArray(),
const int 	maxIters = 2000,
const double 	confidence = 0.995 
)	
```

ä½¿ç”¨å‡½æ•° [findHomography](http://opencv.willowgarage.com/documentation/cpp/calib3d_camera_calibration_and_3d_reconstruction.html?#findHomography) å¯»æ‰¾åŒ¹é…ä¸Šçš„å…³é”®ç‚¹çš„å˜æ¢

- srcPoints	æºå¹³é¢ä¸­ç‚¹çš„åæ ‡çŸ©é˜µï¼Œå¯ä»¥æ˜¯CV_32FC2ç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯vector<Point2f>ç±»å‹
- dstPoints	ç›®æ ‡å¹³é¢ä¸­ç‚¹çš„åæ ‡çŸ©é˜µï¼Œå¯ä»¥æ˜¯CV_32FC2ç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯vector<Point2f>ç±»å‹
- method	è®¡ç®—å•åº”çŸ©é˜µæ‰€ä½¿ç”¨çš„æ–¹æ³•ã€‚ä¸åŒçš„æ–¹æ³•å¯¹åº”ä¸åŒçš„å‚æ•°ï¼Œå…·ä½“å¦‚ä¸‹ï¼š
  0 - åˆ©ç”¨æ‰€æœ‰ç‚¹çš„å¸¸è§„æ–¹æ³•
  RANSAC - RANSAC-åŸºäºRANSACçš„é²æ£’ç®—æ³•
  LMEDS - æœ€å°ä¸­å€¼é²æ£’ç®—æ³•
  RHO - PROSAC-åŸºäºPROSACçš„é²æ£’ç®—æ³•
- ransacReprojThreshold	
  å°†ç‚¹å¯¹è§†ä¸ºå†…ç‚¹çš„æœ€å¤§å…è®¸é‡æŠ•å½±é”™è¯¯é˜ˆå€¼ï¼ˆä»…ç”¨äºRANSACå’ŒRHOæ–¹æ³•ï¼‰ã€‚å¦‚æœ

åˆ™ç‚¹è¢«è®¤ä¸ºæ˜¯ä¸ªå¤–ç‚¹ï¼ˆå³é”™è¯¯åŒ¹é…ç‚¹å¯¹ï¼‰ã€‚è‹¥srcPointså’ŒdstPointsæ˜¯ä»¥åƒç´ ä¸ºå•ä½çš„ï¼Œåˆ™è¯¥å‚æ•°é€šå¸¸è®¾ç½®åœ¨1åˆ°10çš„èŒƒå›´å†…ã€‚

- mask	
  å¯é€‰è¾“å‡ºæ©ç çŸ©é˜µï¼Œé€šå¸¸ç”±é²æ£’ç®—æ³•ï¼ˆRANSACæˆ–LMEDSï¼‰è®¾ç½®ã€‚ è¯·æ³¨æ„ï¼Œè¾“å…¥æ©ç çŸ©é˜µæ˜¯ä¸éœ€è¦è®¾ç½®çš„ã€‚
- maxIters	RANSACç®—æ³•çš„æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œé»˜è®¤å€¼ä¸º2000ã€‚
- confidence	å¯ä¿¡åº¦å€¼ï¼Œå–å€¼èŒƒå›´ä¸º0åˆ°1.

------

### 3. æ¨¡æ¿åŒ¹é…

ç»™å®šä¸€ä¸ªåŸå›¾ï¼Œ åœ¨ç»™å®šä¸€ä¸ªä¸æƒ³è¦ä»åŸå›¾ä¸­æœç´¢å‡ºçš„æ¨¡æ¿å›¾

```c
void cvMatchTemplate	(	const CvArr * 	image,
  const CvArr * 	templ,
  CvArr * 	result,
  int 	method 
  )	
```

Example

ç¼–å†™ä¸€ä¸ªå¿«é€Ÿå–å¾—roiçš„å‡½æ•°ï¼Œ ç„¶åå…ˆä»åŸå›¾ä¸­å–å¾—è¦æ‰¾çš„æ¨¡æ¿ï¼Œ ç„¶åç»™ä¸€å¼ æµ‹è¯•å›¾ç‰‡è¿›è¡Œæµ‹è¯•ï¼Œ çœ‹èƒ½å¦åœ¨æµ‹è¯•å›¾ç‰‡ä¸­ä¹Ÿèƒ½æ‰¾åˆ°ç›®æ ‡

```c++
IplImage* get_ipl_roi(IplImage* src, CvRect rect)
{
	/*
	1. ä¼ å…¥åŸå›¾è·Ÿéœ€è¦å¾—åˆ°çš„roiåŒºåŸŸ
	2. åˆ›å»ºä¸€ä¸ªç©ºå›¾ç”¨æ¥è·å–roi
	3. å°†åŸå›¾ä¸ŠroiåŒºåŸŸcopyåˆ°ç©ºå›¾ç„¶åè¿”å›
	*/
	cvSetImageROI(src, rect); 
	IplImage* tmp = cvCreateImage(cvSize(src->roi->width, src->roi->height), src->depth, src->nChannels);
	cvCopy(src, tmp, NULL);
	cvResetImageROI(src);


	return tmp;
}



IplImage * src_img = cvLoadImage("./images/OK.bmp"); //å–å¾—æ¨¡æ¿ç”¨çš„åŸå›¾
IplImage * test_img = cvLoadImage("./images/test.bmp");//æµ‹è¯•å›¾ç‰‡
IplImage * template_roi = get_ipl_roi(src_img, cvRect(468, 31, 47, 37)); //ä»åŸå›¾å¾—åˆ°è¦æŸ¥æ‰¾çš„æ¨¡æ¿



cvSetImageROI(test_img, cvRect(410, 0, 150, 100)); //æµ‹è¯•å›¾ç‰‡å–roi ï¼šä¸Šé»‘æ ¼å­
IplImage * result = cvCreateImage(cvSize(test_img->roi->width - black->width +1, test_img->roi->height - black->height +1), 32, 1); //ç©ºç”»å¸ƒç”¨æ¥å­˜æ”¾ç»“æœ


cvMatchTemplate(test_img, template_roi, result, 0);


CvPoint minPoint;
CvPoint maxPoint;
double* minVal = 0;
double* maxVal = 0;
cvMinMaxLoc(result, minVal, maxVal, &minPoint, &maxPoint);


cvRectangle(test_img, minPoint, cv::Point(minPoint.x + black->width, minPoint.y + black->height), cv::Scalar(0, 255, 0), 2, 8);
cvShowImage("ã€åŒ¹é…åçš„å›¾åƒã€‘", test_img);
cvRectangle(result, minPoint, cv::Point(minPoint.x + black->width, minPoint.y + black->height), cv::Scalar(0, 0, 0), 3, 8);
cvShowImage("ã€åŒ¹é…åçš„è®¡ç®—è¿‡ç¨‹å›¾åƒã€‘", result);
cv::waitKey(0);

```



------



### 4. å¯¹è§†é¢‘oræ‘„åƒå¤´è¯»å–



#### å¯¹è§†é¢‘oræ‘„åƒå¤´ï¼ˆwebcamï¼‰è¿›è¡Œè¯»å–

```
cv::VideoCapture() ç±» 
```



VideoCaptureæ„é€ å‡½æ•°å¦‚ä¸‹

- videoCapture()
- VideoCapture(const String & filename)
- VideoCapture(const String & filename, int apiPreference)
- VideoCapture(int index)



VideoCapture cap(0)  å¸¦å…¥0 è¡¨ç¤ºå¼€å¯é»˜è®¤æ‘„åƒå¤´

VideoCapture cap("xxxx.mp4") ä¹Ÿå¯ä»¥ä¼ å…¥videoæ–‡ä»¶ï¼Œ ä¹Ÿèƒ½åƒä¸‹é¢è¿™æ ·

VideoCapture cap("img_%02d.jpg") ä¼ å…¥å›¾åƒimg_00.jpg, img_01.jpg, img_02.jpg



```c++
VideoCapture cap; //open the default camera
if (videoFile ï¼= "") //æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°videoFile æœ‰æ²¡æœ‰å€¼
  cap.open(videoFile); //æœ‰çš„è¯ï¼Œ å°±æ‰“å¼€videoFile
else
  cap.open(0);
if(!cap.isOpened()) //æ£€æŸ¥æ˜¯å¦å¯ä»¥è¯»å–è§†é¢‘æ–‡ä»¶å or æ‘„åƒå¤´
  return -1;

namedWindow("Video", 1);
for (;;)
{
  Mat frame; 
  cap >> frame; // ä»æ‘„åƒå¤´è¯»å–å¸§åˆ°frameå˜é‡ä¸Š
  if (frame)//å¦‚æœæœ‰è¯»å–åˆ°
    imshow("Video", frame);//æ˜¾ç¤ºåœ¨å±å¹•ä¸Š
  if (waitKey(30) >= 0) break;
}

//è®°å¾—é‡Šæ”¾æ‰èµ„æº
cap.release();
```



#### ä¿å­˜è§†é¢‘ VideoWriter

è¦ä¿å­˜è§†é¢‘éœ€è¦å…ˆåˆ›å»ºä¸€ä¸ªwriterå®ä¾‹ï¼Œ è®¾ç½®å¥½ä¸€åˆ‡çš„å‚æ•°

```c++
cv::VideoWriter::VideoWriter
```

VideoWriterä¸»è¦æ„é€ å‡½æ•°å¦‚ä¸‹

```c++
//1
cv::VideoWriter::VideoWriter	(	
  const String & 	filename, 
  int 	fourcc, 
  double 	fps, 
  Size 	frameSize, 
  bool 	isColor = true )

//2  
cv::VideoWriter::VideoWriter	(	const String & 	filename, int 	apiPreference,
int 	fourcc, double 	fps, Size 	frameSize, bool 	isColor = true 
)	
```

- fpsï¼šä»¥å¤šå¤§çš„å¸§ç‡ä¿å­˜*
- Fourcc ï¼š å››å­—ç¬¦codeè¡¨ç¤ºå‹ç¼©å¸§çš„æ–¹å¼
  - å¯å‚è€ƒ http://www.fourcc.org/codecs.php
- frameSizeï¼šå›¾åƒçš„å¤§å°ï¼Œsizeç±»å‹
- isColorï¼šæ˜¯å¦æ˜¯å½©è‰²å›¾åƒ*

Ex.

```c++
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
 
using namespace cv;
 
void main()
{
	VideoCapture capture(0);
	VideoWriter writer("VideoTest.avi", CV_FOURCC('M', 'J', 'P', 'G'), 25.0, Size(640, 480));
	Mat frame;
	
	while (capture.isOpened())
	{
		capture >> frame; //è¯»å–æ¯ä¸€å¸§, ç”¨æ³•ç›¸å½“äºread()
		writer << frame; //ä¿å­˜æ¯ä¸€å¸§ï¼Œ ç”¨æ³•ç›¸å½“äºwrite()
		imshow("video", frame);
		if (cvWaitKey(20) == 27)
		{
			break;
		}
	}
}
```



#### ç¨‹åºè®¡æ—¶

åˆ©ç”¨opencvè‡ªå¸¦çš„æ¨¡å—

```c++
float start = getTickCount(); //è®¡æ—¶å™¨
//è®¡æ—¶ç¨‹åº

float end = getTickCount();

float last = end-start;

cout << "time consume: " << (last / getTickFrequency() * 1000) << endl;

//getTickFrequencyè¡¨ç¤ºCPUçš„é¢‘ç‡ï¼Œè¿™é‡Œç”¨çš„æ˜¯opencvç‰ˆçš„ï¼Œ*1000å¯ä»¥è½¬æ¢ä¸ºç§’

//æ€»æ¬¡æ•°/ä¸€ç§’å†…é‡å¤çš„æ¬¡æ•°*1000 = æ—¶é—´(ms) 
//æ€»æ¬¡æ•°/ä¸€ç§’å†…é‡å¤çš„æ¬¡æ•°*1000000 = æ—¶é—´(s)
```



opencv3.2 è‡ªå¸¦æ¨¡å—

```
cv::TickMeter
```





```cpp
#include "opencv2/opencv.hpp"

TickMeter tm; //å®šä¹‰timer
timer.start();
// do something ...
timer.stop();
std::cout << timer.getTimeSec();//è¾“å‡ºæ˜¯s
```

getTimeMicro() //è¿”å›å¾®ç§’ us

getTimeMilli() //è¿”å›æ¯«ç§’ ms

getTimeSec() //è¿”å›ç§’ s



#### è®¡ç®—FPS å¹¶æ˜¾ç¤ºåœ¨å›¾åƒ

Example

```c++
#include <ctime> //for recored time


long frameCounter = 0;
std::time_t timeBegin = std::time(0);
int tick = 0;
int fps = 0;
cv::Mat frame;

while(true)
{
    cap.read(frame);
    frameCounter++;
    std::time_t timeNow = std::time(0) - timeBegin; //è®¡ç®—æ—¶é—´
    if (timeNow - tick >= 1)
    {
      tick++;
      //            std::cout << "Frames per second: " << frameCounter << std::endl;
      fps = frameCounter;
      frameCounter = 0;
    }
    cv::putText(frame, cv::format("Average FPS=%d",fps),
                cv::Point(30, 30), cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0,0,255));
    cv::imshow("CSI Camera",frame); 
}
```



------

### 5. å„ç±»å‹

#### Vec å¯¹è±¡ç±»å‹ 

æ•°å€¼å‘é‡çš„æ¨¡æ¿ç±»ï¼Œ å®šä¹‰å‘é‡çš„ç±»å‹å’Œç»„ä»¶çš„æ•°é‡

å®˜æ–¹é¢„å®šä¹‰çš„ç±»å‹

```c++
typedef Vec<unchar, 4> Vec4b;
typedef Vec<int, 2> Vec2i;
typedef Vec<float, 2> Vec2f;
typedef Vec<double, 2> Vec2b;
```

#### Scalarå¯¹è±¡ç±»å‹

ç”±Vecæ´¾ç”Ÿçš„æ¨¡æ¿ç±»ï¼Œ ç”¨äºä¼ é€’å’Œè¯»å–åƒç´ å€¼

ä»¥ä¸‹æ˜¯åˆå§‹åŒ–çš„æ–¹å¼

```c++
Scalar s0(0); //èµ‹å€¼
Scalar s1(0.0, 1.0, 2.0, 3.0); //èµ‹å¤šå€¼
Scalar s2(s1);//é å¦ä¸€ä¸ªå€¼èµ‹äºˆå€¼
```

#### Point å¯¹è±¡ç±»å‹

ä¸»è¦ç”¨æ¥æè¿°2Dåæ ‡å¹³é¢ä¸Šçš„ç‚¹ ï¼ˆx, y)

```c++
typedef Point_<int> Point2i;
typedef POint2i Point;
typedef Point_<float> POint2f;
typedef Point_<double> POint2d;
```

Ex.

```c++
Point pt;
pt.x = 10;
pt.y = 8;

// æˆ–è€…å¦‚ä¸‹

Point pt =  Point(10, 8);
```



#### Sizeå¯¹è±¡ç±»å‹

é€šå¸¸ç”¨äºæŒ‡å®šå›¾åƒæˆ–çŸ©å½¢å¤§å°ï¼Œ è¿™ä¸ªç±»æ·»åŠ äº†ä¸¤ä¸ªæˆå‘˜ width å’Œ heightï¼Œ ä»¥åŠarea()å‡½æ•°

```c++
Size s(100, 100);
Mat img = Mat::zeros(s, CV_8UC1); // 100 x 100 å•é€šé“matrix
s.width = 200;
int area = s.area(); //returns 100x200
```

#### Rect å¯¹è±¡

å°±æ˜¯çŸ©å½¢å¯¹è±¡

ä¹Ÿå¯ä»¥ç”¨æ¥å®šä¹‰ROIï¼ˆregion of interest, ç®€ç§°ROI)

`Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)`

å®šä¹‰ä¸€ä¸ªå·¦ä¸Šè§’ç‚¹åæ ‡ä¸º`(_x, _y)`ï¼Œ `_width*_height`çŸ©å½¢çš„å®½å’Œé«˜

```c++
Mat img = imread("lena,jpg");
Rect rect_roi(0, 0, 100, 100);
Mat img_roi = img(r); //åŸå›¾ ä»å·¦ä¸Šx:0 y:0çš„ä½ç½® å–height, width = 100è¿›è¡Œå‰ªè£
```

#### C æ¥å£

CvSize

CvRect

CvPoint

CvScalar





------

### API

#### namedWindows()

```c++
void namedWindow(const string& winname, int flags=WINDOW_AUTOSIZE )
```

**name** â€“ windowçš„åå­—ï¼Œ ä¹Ÿå¯ç”¨æ¥è¾¨åˆ«æ˜¯å¦ä¸ºåŒä¸€ä¸ªè§†çª—

**flags** â€“Flags of the window. The supported flags are:

â€‹	- WINDOW_NORMAL ï¼š å¦‚æœè®¾å®šä¸ºè¿™ä¸ªï¼Œ åˆ™userå¯ä»¥è‡ªè¡Œresize window

â€‹	- WINDOW_AUTOSIZE ï¼š å¦‚æœè®¾å®šè¿™ä¸ªï¼Œ userä¸èƒ½è‡ªå·±resize windowï¼Œ ä¼šè‡ªåŠ¨çš„è°ƒæ•´æˆè¦displayçš„å›¾åƒä¸€æ ·

â€‹	- WINDOW_OPENGL  å¦‚æœè®¾å®šè¿™ä¸ªï¼Œ åˆ™å¯ä»¥support openGL

#### convertTo()  è½¬æ¢æ•°æ®ç±»å‹

```c++
void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const
```



æŠŠä¸€ä¸ªçŸ©é˜µä»ä¸€ç§æ•°æ®ç±»å‹è½¬æ¢åˆ°å¦ä¸€ç§æ•°æ®ç±»å‹ï¼ŒåŒæ—¶å¯ä»¥å¸¦ä¸Šç¼©æ”¾å› å­å’Œå¢é‡ï¼Œå…¬å¼å¦‚ä¸‹ï¼š

```cpp
m(x,y) = saturate_cast<rType>(alpha * (*this) (x,y) + beta);
```

> m       â€“ ç›®æ ‡çŸ©é˜µã€‚å¦‚æœmåœ¨è¿ç®—å‰æ²¡æœ‰åˆé€‚çš„å°ºå¯¸æˆ–ç±»å‹ï¼Œå°†è¢«é‡æ–°åˆ†é…ã€‚
>
> rtype â€“ ç›®æ ‡çŸ©é˜µçš„ç±»å‹ã€‚å› ä¸ºç›®æ ‡çŸ©é˜µçš„é€šé“æ•°ä¸æºçŸ©é˜µä¸€æ ·ï¼Œæ‰€ä»¥rtypeä¹Ÿå¯ä»¥çœ‹åšæ˜¯ç›®æ ‡çŸ©é˜µçš„ä½æ·±åº¦ã€‚å¦‚æœrtypeä¸ºè´Ÿå€¼ï¼Œç›®æ ‡çŸ©é˜µå’ŒæºçŸ©é˜µå°†ä½¿ç”¨åŒæ ·çš„ç±»å‹ã€‚
>
> alpha â€“ å°ºåº¦å˜æ¢å› å­ï¼ˆå¯é€‰ï¼‰ã€‚é»˜è®¤å€¼æ˜¯1ã€‚å³æŠŠåŸçŸ©é˜µä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½ä¹˜ä»¥alphaã€‚
>
> beta   â€“ é™„åŠ åˆ°å°ºåº¦å˜æ¢åçš„å€¼ä¸Šçš„åç§»é‡ï¼ˆå¯é€‰ï¼‰ã€‚é»˜è®¤å€¼æ˜¯0ã€‚å³æŠŠåŸçŸ©é˜µä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½ä¹˜ä»¥alphaï¼Œå†åŠ ä¸Šbetaã€‚



#### cv::putText()

å°†ç¼–è¾‘å¥½çš„æ–‡å­—æ”¾åœ¨å›¾åƒimgä¸Š

```c++
void cv::putText (intputoutputarray img, const String & text, Point org, int fontFace,o double fontscale, Scalar color, int thickness = 1, int lineType = LINE_8,  bool bottomLeftOrigin = false)
```

- img : Image.
- text: Text string to be drawn.
- org : Bottom-left corner of the text string in the image.
- fontFace : Font type, see [HersheyFonts](https://docs.opencv.org/3.4/d0/de1/group__core.html#ga0f9314ea6e35f99bb23f29567fc16e11).
- fontScale : Font scale factor that is multiplied by the font-specific base size.
- color : Text color.
- thickness : Thickness of the lines used to draw a text.
- lineType: Line type. See [LineTypes](https://docs.opencv.org/3.4/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777)
- bottomLeftOrigin : When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.

#### cv::getTextSize() 

```c++
Size cv::getTextSize(const String & text, int fontFace, double fontScale, int thickness, int * baseLine)
```

è¾“å…¥ä¼ å…¥çš„textä»¥åŠç»™å®šçš„å­—ä½“å¤§å°ç­‰ è®¡ç®—å‡ºéœ€è¦çš„é•¿åº¦å’Œå®½åº¦

- text è¾“å…¥çš„æ–‡æœ¬
- fontFace æ˜¯å­—ä½“ç±»å‹
- fontScale å­—ä½“å¤§å°
- thicknesså­—ä½“ç²—ç»†
- BaseLine æ–‡å­—æœ€åº•éƒ¨yåæ ‡



Example

```c++
String text = "Funny text inside the box";
int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
double fontScale = 2;
int thickness = 3;
Mat img(600, 800, CV_8UC3, Scalar::all(0));
int baseline=0;
Size textSize = getTextSize(text, fontFace,
                            fontScale, thickness, &baseline);
baseline += thickness;
// center the text
Point textOrg((img.cols - textSize.width)/2,
              (img.rows + textSize.height)/2);
// draw the box
rectangle(img, textOrg + Point(0, baseline),
          textOrg + Point(textSize.width, -textSize.height),
          Scalar(0,0,255));
// ... and the baseline first
line(img, textOrg + Point(0, thickness),
     textOrg + Point(textSize.width, thickness),
     Scalar(0, 0, 255));
// then put the text itself
putText(img, text, textOrg, fontFace, fontScale,
        Scalar::all(255), thickness, 8);
```



#### cv::rectangle() ç»˜åˆ¶çŸ©å½¢

Void cv::rectangle(inputoutputarray img, Point pt1, Point2 pt2, const Scalar & color, int thickness = -1, int lineType = LINE_8, int shift = 0)

- Img ï¼š image
- pt1 : å·¦ä¸Šåæ ‡ç‚¹
- pt2 : å³ä¸‹åæ ‡ç‚¹
- color : æ¡†çš„é¢œè‰²
- thickness ï¼šæ¡†çš„åšåº¦
- lineTypeï¼šçº¿æ¡æ ·å¼
- Shift ï¼š å‡ ä¹ä¸ç”¨ï¼Œ é»˜è®¤ä¸º0









------



### CMakeLists.txt ç¼–å†™



æƒ…å†µ

```
Hello æ–‡ä»¶å¤¹
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ cmake-build-debug
â”œâ”€â”€ main.cpp
â””â”€â”€ src
```



CMakeLists.txt ç¼–å†™èŒƒä¾‹

```cmake
cmake_minimum_required(VERSION 3.15)
project(Hello)


set(CMAKE_CXX_STANDARD 14)
find_package(OpenCV REQUIRED)
message("OpenCV version: " ${OpenCV_VERSION})
#openCV
include_directories(${OpenCV_INCLUDE_DIRS})
link_directories(${OpenCV_LIB_DIR})

#set source file
set(src main.cpp)


add_executable(${PROJECT_NAME} ${src})
target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})
```







------



### Gstreamer



#### CSI camera å¼€å¯webcamæ–¹å¼

ä»£ç å‚è€ƒ [https://github.com/JetsonHacksNano/CSI-Camera/blob/master/simple_camera.cpp](https://github.com/JetsonHacksNano/CSI-Camera/blob/master/simple_camera.cpp)

Example

```c++
// #include <iostream>
#include <opencv2/opencv.hpp>
// #include <opencv2/videoio.hpp>
// #include <opencv2/highgui.hpp>

std::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) {
    return "nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)" + std::to_string(capture_width) + ", height=(int)" +
           std::to_string(capture_height) + ", format=(string)NV12, framerate=(fraction)" + std::to_string(framerate) +
           "/1 ! nvvidconv flip-method=" + std::to_string(flip_method) + " ! video/x-raw, width=(int)" + std::to_string(display_width) + ", height=(int)" +
           std::to_string(display_height) + ", format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink";
}

int main()
{
    int capture_width = 1280 ;
    int capture_height = 720 ;
    int display_width = 1280 ;
    int display_height = 720 ;
    int framerate = 60 ;
    int flip_method = 0 ;

    std::string pipeline = gstreamer_pipeline(capture_width,
	capture_height,
	display_width,
	display_height,
	framerate,
	flip_method);
    std::cout << "Using pipeline: \n\t" << pipeline << "\n";
 
    cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER);
    if(!cap.isOpened()) {
	std::cout<<"Failed to open camera."<<std::endl;
	return (-1);
    }

    cv::namedWindow("CSI Camera", cv::WINDOW_AUTOSIZE);
    cv::Mat img;

    std::cout << "Hit ESC to exit" << "\n" ;
    while(true)
    {
    	if (!cap.read(img)) {
		std::cout<<"Capture read error"<<std::endl;
		break;
	}
	
	cv::imshow("CSI Camera",img);
	int keycode = cv::waitKey(30) & 0xff ; 
        if (keycode == 27) break ;
    }

    cap.release();
    cv::destroyAllWindows() ;
    return 0;
}

```

#### CSI camera Video Writeçš„æ–¹å¼

```C++
cv::VideoWriter writer;
    writer.open("appsrc ! autovideoconvert ! omxh265enc ! matroskamux ! filesink location=test.mkv ", 0, (double)25, cv::Size(1024, 1024), true);
```







#### é—®é¢˜åˆé›†



**é—®é¢˜** execute:532 Failed to create CaptureSession CSIæ‘„åƒå¤´æ— æ³•æ­£å¸¸å¼€å¯, éœ€è¦reboot è®¾å¤‡æ‰è¡Œ

**åŸå› ** åº”è¯¥æ˜¯å‰é¢ä½¿ç”¨çš„gstreameræœªæ­£å¸¸å…³é—­oré‡Šæ”¾

**è§£å†³** 

python version

```python
def gstreamer_auto(self):
return ('nvarguscamerasrc ! '
'video/x-raw(memory:NVMM), format=NV12, '
'width=3280, height=2464, '
'framerate=10/1 ! '
'nvvidconv flip-method=2 ! '
'video/x-raw, format=I420 ! '
'appsink max-buffers=1 drop=True ')
```

c++ version 

```c++
std::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) {
    return "nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)" + std::to_string(capture_width) + ", height=(int)" +
           std::to_string(capture_height) + ", format=(string)NV12, framerate=(fraction)" + std::to_string(framerate) +
           "/1 ! nvvidconv flip-method=" + std::to_string(flip_method) + " ! video/x-raw, width=(int)" + std::to_string(display_width) + ", height=(int)" +
           std::to_string(display_height) + ", format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink max-buffers=1 drop=True ";
}
```



å‚è€ƒhttps://devtalk.nvidia.com/default/topic/1066047/jetson-nano/how-to-free-restart-the-gstreamer-nvarguscamerasrc-module/



**é—®é¢˜**

OpenCV Error: Unsupported format or combination of formats (cvWriteFrame() needs images with depth = IPL_DEPTH_8U and nChannels = 3.) in CvVideoWriter_GStreamer::writerFrame

**åŸå› ** 

éœ€è¦å°†å›¾åƒè¿›è¡Œç±»å‹è½¬æ¢åˆ©ç”¨ convertTo(), ç±»å‹ä¸º

**è§£å†³**

https://devtalk.nvidia.com/default/topic/985594/general-graphics-programming/how-to-write-video-frames-from-visionworks-to-gstreamer-pipe/



#### info

[jetson Nano GStreamer example pipelines for H264 H265 and VP8 decoding](https://developer.ridgerun.com/wiki/index.php?title=Jetson_Nano/Gstreamer/Example_Pipelines/Decoding)

------

### å…¶ä»–



éšæœºäº§ç”Ÿæ•°å­—Random Number Generator

cv::RNG ç±»

https://docs.opencv.org/master/d1/dd6/classcv_1_1RNG.html#details



randomColor



### CommandLineParser ç®¡ç†å‘½ä»¤è¡Œå‚æ•°

ä¸»è¦å…ˆåœ¨å¸¸é‡charå‘é‡ä¸­å®šä¹‰éœ€è¦æˆ–å…è®¸çš„å‚æ•°

```
const char* keys = 
{
	"{help h usage ? | | print this message}" #å®šä¹‰helpå‚æ•°
	"{@video | | Video file, if not defined try to use webcamera}"
}

#æ ¼å¼ä¾ç…§å¦‚ä¸‹
"{name_param | default_value | description}"
name_param å¯ä»¥@å¼€å¤´ï¼Œ å°†å‚æ•°å®šä¹‰ä¸ºé»˜è®¤è¾“å…¥


CommnadLineParser parser(argc, argv, keys);
```



**é—®é¢˜**

OpenCV Error: Assertion failed (scn == 3 || scn == 4) in cv::cvtColor

è¯´æ˜cvtColorå£°æ˜å¤±è´¥



#### å›¾åƒå…ƒç´ ç±»å‹

```
Type:ç±»å‹ CV_[ä½æ•°][å¸¦ç¬¦å·ä¸å¦][ç±»å‹å‰ç¼€][é€šé“æ•°]
ä¾‹:CV_8UC3è¡¨ç¤ºä½¿ç”¨8ä½çš„unsighed charç±»å‹.æ¯ä¸ªåƒç´ ç”±ä¸‰ä¸ªå…ƒç´ ç»„æˆçš„ä¸‰é€šé“.
CV_64FC1 Fè¡¨ç¤ºfloat channel = 1

ç±»å‹æ±‡æ€»:
CV_8U  (8 bit æ— ç¬¦å·æ•´å½¢0~255) CV_8UC1 (1é€šé“)  CV_8UC2 (2é€šé“)  CV_8UC3 (3é€šé“)  CV_8UC4(4é€šé“) 
CV_8S   (8 bitæœ‰ç¬¦å·æ•´å½¢-128~127)
CV_8SC1 (1é€šé“)  CV_8SC2 (2é€šé“)   CV_8SC3 (3é€šé“)  CV_8SC4 (4é€šé“)   

CV_16U  (16 bit æ— ç¬¦å·æ•´å½¢0~65535)
CV_16UC1 (1é€šé“)  CV_16UC2 (2é€šé“)   CV_16UC3 (3é€šé“)   CV_16UC4 (4é€šé“)   

CV_16S  (16 bit æœ‰ç¬¦å·æ•´å½¢-32768~32767)
CV_16SC1(1é€šé“)   CV_16SC2(2é€šé“)   CV_16SC3(3é€šé“)   CV_16SC4(4é€šé“)   

CV_32S  (32 bit æœ‰ç¬¦å·æ•´å½¢-2147483648~2147483647)
CV_32SC1   CV_32SC2    CV_32SC3  CV_32SC4   

CV_32F  (32 bit æµ®ç‚¹)
CV_32FC1   CV_32FC2  CV_32FC3   CV_32FC4  

CV_64F   (64 bit æµ®ç‚¹)
CV_64FC1   CV_64FC2  CV_64FC3  CV_64FC4  
```



------

### å‚è€ƒèµ„æ–™

OpenCV æ–‡æ¡£ç›®å½• https://docs.opencv.org/
